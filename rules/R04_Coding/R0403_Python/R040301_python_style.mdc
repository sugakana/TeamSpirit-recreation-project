---
description: Pythonプロジェクト全体に適用する基本的なコーディング規約を定義するルール
globs: **/*.py
alwaysApply: false
---
# Python コーディング規約

このルールは、Pythonのコーディング規約について定義します。

## 3.1 Python命名規約

このルールは、Python開発における命名規約の詳細を定めます。

### 3.1.1 ハンガリアン記法について
- 原則としてハンガリアン記法は採用しません。
- 採用しない理由：
  - Pythonでは全ての型の略語を管理するのは不可能であり、プレフィックス付加を徹底できないため。
  - 変数のスコープは最小限に設定され、IDE等で型の判断が容易なため。
  - 特定のコンポーネントにプレフィックス・サフィックスを付けたい場合は、後述の命名指針でカバー可能なため。
- ※ハンガリアン記法とは、変数の型・役割を略語化し、プレフィックスとして変数名に組み入れる記法です。

### 3.1.2 命名に関する基本指針
- 正しくフルスペルで変数/フィールド/クラス等を命名する。
  - 例：firstName, grandTotal, CorporateCustomer
  - x1, y1, fnのような意味不明な略称は避ける。
- 業務分野の用語を適切に使用する。
  - 例：顧客を「Customer」と定義している場合、Client等の別単語は使わない。
- 略語は控えめにし、使用する場合は統一する。
  - 例：numberの省略形はnum等、標準リストを作成し一貫して使用。
- あまりに長すぎる名前は避ける（目安：15文字以下）。
- ほんの些細な違いしかない名前は使用しない。
  - 例：anSqlDatabase, anSQLDatabase
- 標準的な略語は、属性名は小文字始まり、クラス名は先頭のみ大文字。
  - 例：sqlDataBase（属性）、SqlDatabase（クラス）
- RDBMSのテーブル項目名称はそのまま使用し、独自の英単語やローマ字は定義しない。
- 上記以外の専門用語はヘボン式ローマ字を使用。
- 上記以外の一般的な単語は平易な英単語を使用。

### 3.1.3 使用可能な文字
- 半角英数字およびアンダースコア（_）

### 3.1.4 命名スタイル
| スタイル | 説明 | 例 |
|---|---|---|
| アッパーキャメルケース（パスカルケース） | 単語先頭大文字 | UserInfo, MessageUtil |
| ローワーキャメルケース（キャメルケース） | 先頭単語のみ小文字、以降は単語先頭大文字 | value, maxLength |
| スネークケース | 全て大文字、単語区切りにアンダースコア | CHAR_LENGTH |
| ローワースネークケース | 全て小文字、単語区切りにアンダースコア | char_length |

## 3.2 設計に関する指針

### 3.2.1 スコープ設計

#### 3.2.1.1 スコープ設計の基本指針
- クラス／メソッド／フィールドのアクセス可能性や変数のスコープは、可能な限り最小限となるように設計する。
- 可能な限り狭いスコープで設計すること。

#### 3.2.1.2 アクセス可能性の設計
- Pythonではアクセス修飾子の代わりに命名規約を用いてアクセス可能性を設計する。
- 基本的に`private`（非公開）を優先し、必要に応じてスコープを広げる。
- JavaScriptにおけるアクセス可能性の優先順位は以下の通り：
  | 優先順位 | 命名規約 | アクセス可能性 |
  |---|---|---|
  | 1 | 「__」で始まる | private |
  | 2 | 「_」で始まる | protected |
  | 3 | 上記以外 | public |

#### 3.2.1.3 変数スコープ設計
| スコープの種類 | 説明 |
| --- | --- |
| ローカル（local）| 関数内で定義された変数のスコープ。Pythonでは、if文やfor文などのブロックではスコープは分かれない。|
|ノンローカル（nonlocal）|関数の内側に定義された関数が、外側関数のローカル変数を参照・変更したい場合に使用。|
|グルーバル（global）|モジュールレベルで定義された変数。関数内からアクセス・変更するには`global`キーワードが必要。|
|ビルトイン（builtin）|`len`や`print`など、Pythonにあらかじめ組み込まれた関数や変数が属するスコープ。|

- 関数内関数（ネスト関数）やノンローカルスコープは極力使用しないこと
  - 可読性・保守性が下がるため。
  - モジュールやクラスレベルの関数を原則使用とする。
  - やむを得ず使用する場合は、設計上の意図をドキュメントに明記する。
- 変数の有効スコープは可能な限り狭く設計する。
- 変数は「使用する直前」で宣言する。
  - 例えば、メソッドの途中で使う変数は、メソッドの戦闘ではなく、その変数を使用する直前で宣言する。
  - 定義箇所と使用箇所を同じブロックにすることで、意図が明確になり、変数名の競合エラーも防げる。
- 変数は「使用するブロック内」で宣言する。
  - 例えば、メソッド内で使う変数はそのメソッド内で、さらに特定のブロック（`if`や`for`等）でしか使わない場合はそのブロック内で宣言する。
-ブロック（`try-except`,`if`,`for`,`while`等）を意識して変数スコープを設計する。
  - Pythonではブロックスコープが存在しないが、論理的なスコープ設計を行うことで、可読性と安全性を高める。

## 3.3 実装に関する指針

### 3.3.1 宣言

#### 3.3.1.1 型宣言
- Pythonにおいては、原則として、型宣言を行うことは出来ない。

#### 3.3.1.2 その他の宣言
- 不要なimport宣言は書かない（存在する場合は除去する）。
- ワイルドカード（*）を使用したimport宣言は禁止。
- 正しい順でimportする。
  - 不正な順でimportすると、Pylintの警告が発生する。警告を放置せず、正しい順にimportすること。
- 1行で複数importしても構わない。
  - `from ... import A, B, C`のような構文で、複数importすることは、許可する。
- 原則として、asによる省略名は使用しない。
  - 長すぎる故に特別に規定されているケースを除き、基本は`from ... import SomeClass as SC`のような短縮形は、使用しないこと。特に、開発者ごとにまちまちな省略名を使用することは禁止し、使用する場合はプロジェクトで統一すること。

### 3.3.2 初期化

#### 3.3.2.1 変数の初期化
- 暗黙的に設定される初期値を意識する。
  - Pythonの場合、変数に対して明示的に初期化がなされない場合は、暗黙的な初期化は行われず、全て「None」として定義される。
- 「null」、「Null」等ではなく、「None」である。
  - 一般的な言語における「null」は、Pythonの場合「None」である。未初期化値を明示的に代入する場合は、「null」「Null」などではなく、「None」を代入すること。

#### 3.3.2.2 コンストラクタ
- コンストラクタは「__init__()」で定義する。
  - Java等、多くの言語ではコンストラクタは「クラス名と同名の関数」を定義するが、Pythonの場合、「__init__」という特殊な名前の関数でコンストラクタを定義する。
- 引数無しのコンストラクタの必要性を意識する。
  - Pythonの場合、Javaのような「メソッドのオーバーロード」、即ち「同一名の関数を、引数を変えて複数定義する」といったことは出来ないが、「引数のデフォルト値」を定義することにより、Javaのオーバーロードと近しい機能を実現出来る。よって、「引数無しのコンストラクタ」「引数有のコンストラクタ」を両方使用したい場合は、コンストラクタの引数に適切なデフォルト値を設定すること。
- 親クラスのコンストラクタはsuperを使って呼び出すこと。
  - Pythonは、Javaと異なり、暗黙的に親クラスのコンストラクタが呼び出されることはないが、Pylintによる警告は発生する。よって、superを使用し、適切に親クラスのコンストラクタを呼び出すこと（欄外の※ サンプルコード１を参照）。
- staticクラス（privateなコンストラクタ）は定義しない。
  - Javaの場合、クラスに属さない関数が定義できないため、インスタンス化せずに利用可能にしたいユーティリティ関数や定数などは、「staticクラスのstaticメンバー」として、定義する。その際、staticクラスはインスタンス化できないように、コンストラクタをプライベートにする。一方、Pythonの場合、クラスに属さない関数も定義できるため、わざわざstaticクラスを定義する必要はない。よって、コンストラクタをprivate化するような考慮は、必要ない。

  ※1 サンプルコード
    - 例えば、以下のように親クラスのコンストラクタを呼び出すことができる。
      【親クラスのコンストラクタ呼出し】
      ```python
      class Prent():
        def __init__(self, value=5):
          self.value = value
          print('super init')
      # (続く)
      ```

      ```python
      # (続き)
      class SubClass(Parent):
        def __init__(self):
          super(__class__, self).__init__()
          print('sub init')

      # メイン関数
      if __name__ == "__main__":
        hoge = SubClass()
        print(hoge.value)
      ```
      実行結果は、以下のようになる。
      【サンプルコードの実行結果】
      ```
      super init
      sub init
      5
      ```

### 3.3.3 判定文（if, forなど）


#### 3.3.3.1 無駄なelseの除去
- 不必要なelse文節がある場合は、else文節を除去して見通しを良くする。

【修正前】無駄なelse文節がある判定文:
```python
# 無駄なelseがある判定文
def sampleMethod(i):
  if i == 1:
    return i
  else:
    return 2
```

【修正後】無駄なelse文節を除去して見通しを良くした判定文:
```python
def sampleMethod(i):
  if i == 1:
    return i
  return 2
```

#### 3.3.3.2 条件判定の反転
- 判定文内のブロックが長い、または、判定文内のネスト構造が深い等の問題は、条件判定の斑点を利用して、見通しを良くする。

【修正前】長いネストされたブロックがある判定文:
```python
def sampleMethod(i, expression):
  j = 0
  if expression:
    # 処理
    # 処理
    # 処理
    # 処理
    # 処理
  else:
    j = i
  return j
```

【修正後】条件判定を反転してネストを除去し、同時にブロックを短くした判定文:
```python
def sampleMethod(i, expression):
  if not expression:
    return i
  

  # 処理実行
  j = 0
  # 処理
  # 処理
  # 処理
  # 処理
  # 処理
  return j
```

#### 3.3.3.4 組み合わせ判定のメソッド化
- 条件判定が複雑な組み合わせによって構成される場合は、メソッド化して見やすくする。
- メソッドは何を判定しているか分かる適せるな関数名を利用する。

【修正前】複雑な条件判定の組み合わせがある判定文:
```python
def sampleMethod(a, b, c):
  if a and (b or c):
    return 1
  elif (a or b) and c:
    return 2
  return 3
```

【修正後】複雑な条件判定の組み合わせをメソッド化した判定文:
```python
def sampleMethod(a, b, c):
  if isSomething(a, b, c):
    return 1
  elif isOther(a, b, c):
    return 2
  return 3
```

### 3.3.4 エラー処理

#### 3.3.4.1 例外処理
- 全て、非検査例外
  - Javaのような、必ずcatchしなければならない「検査例外」と、catch不要の「非検査例外」には分かれていない。よって、利用者にcatchして欲しい例外をスローする場合は、特にdocstring（JavaにおけるJavaDocに相当）に明記する必要がある。
- 構文エラー（SyntaxError）と例外（exception）の違いを意識する
  - 前者は、構文解釈上のエラーであり、「例外」という機構となってはいるが、Javaにおける「コンパイルエラー」に相当するものであり、後者が、Javaにおける「例外」に相当する。
- 例外のキャッチはサブ例外クラスから優先的に行う
  - ある例外と、それを継承したサブ例外を個別に処理する場合、サブ例外よりも先に親例外をキャッチしてしまうと、サブ例外に対する処理が隠蔽されてしまう。この様な場合、サブ例外を先にキャッチするように記述しなければならない。
- 例外を隠蔽しない
  - キャッチした例外は、必ず処理しなければならない。そうで無い場合は、そのままリスローし、システム共通の例外処理に任せる。
- キャッチすべきでない例外を不正にキャッチしない
  - フレームワークによって対処される例外等を、アプリケーションでむやみにキャッチしない。フレームワークのデフォルトの例外処理を拡張したいなどの明確な理由がある場合にのみキャッチし、そうでない場合は、仮にキャッチしたとしても、再スローする。
- EAFPとLBYLの違いを意識する
  - Javaの場合、「例外を正常な状況で使用しない」即ち、例外クラスは、あくまで「例外」であり、処理に必要なコストも高く、パフォーマンスも劣化するため、正常処理にて予想される事象に対して例外を利用してはならない。」ということが、鉄則であった。このようなプログラミングスタイルは「Look before you leap（飛ぶ前に見ろ/転ばぬ先の杖）」の頭文字を取って「LBYL」と呼ばれ、if文がよく出てくるのが特徴である。JavaやC#のような静的なプログラミング言語と、相性が良い。一方、動的言語であるPythonの場合、LBYLスタイルを完全に徹底しようとすると、プロパティ名などの存在チェック（if文）をいちいち行う必要があり（コンパイルチェックされないため）、一般的には相性が悪いとされている。これらの動的言語では、「Easier to  ask for forgieveness than permission」（ゴメンナサイはオネガイシマスより楽）の頭文字を取った「EAFP」スタイル即ち、try～catchを多用するプログラミングスタイルの方が相性が良いと、考えられている。事前にif文で細かくチェックするのではなく、「例外が発生するようであれば必要に応じてtry～catchする」という、事後的なプログラミングスタイルである。本規約でも、この考え方に則り、Pythonの場合はEAFP的に、正常な状況でも例外を使用しても良いものとする。
- finally句でreturnやthrowをしない
  - finally句で値を戻したり例外のスローを行うと、tryブロック内で発生した例外が失われてしまう。
- withによるfinallyの代替を意識する
  - 一般的なプログラミング言語の場合、finallyは、「ファイルなどのオープンしたリソースを、例外発生時にも漏れなくクローズする」ために用いられることが多いが、Pythonの場合、with文によりそれが達成できる場合がある。
  - 例えば、ファイルオーブンの場合、以下のようにwith文を使用すれば、withを抜ける際に、たとえ例外が発生した場合でも、オープンしたファイルが必ずクローズされる。いくつかのPythonのオブジェクトには、同様にwithに対応したオブジェクトが存在するため、finallyを記述する際はまずそのオブジェクトの「クリーンアップ動作」を調べること。
  【Pythonによるファイルオープン処理】
  ```python
  with open('somefile.txt') as f:
    for lune in f:
      print(line, end='')
  ```

#### 3.3.4.2 独自例外の作成について
- 体系化された例外クラスを活用し、むやみに独自の例外クラスを定義しない

### 3.3.5 その他
- null及びNull参照について
  - Null参照、いわゆる、JavaにおけるNullPointerExceptionが発生するケースでは、Pythonにおいては大抵の場合、「AttributeError」（AttributeError: 'Xxx' object has no attribute 'yyy'）という例外が発生する。null、および、Null参照は非常に忘れられ易く、バグの原因となり易い。変数やメソッドの戻り値がNone（Pythonにおけるnull）である可能性、および、Null参照に対し、常に考慮すること。
- マジックナンバーの定数化
  - 区分値（1：本社、2：○○事業所、3：××営業所）等の、数値自体に意味がある、いわゆるマジックナンバーについては、可読性や保守性の観点から、定数定義すること。
- 変数の読み替えないをしない
  - 状況によって異なる対象を、１つの変数に格納し、状況によって読み替えて使用してはならない。このような変数の読み替えは、可読性や保守性を低下させる。変数は、同じ対象を指し示すものとして、定義すること。
- 文字列連結における「+」演算子について
  - Javaと異なり、Pythonにおいては、文字列連結時に「+」演算子を用いても問題無い。
- インスタンス化する際に「new」演算子は使用しない
  - 多くのオブジェクト指向言語では、クラスからインスタンスを生成する際にnew演算子を使用するが（someVar = new SomeClass(); など）、Pythonの場合は使用しない。「some_var = SomeClass()」のように、newを用いず、クラス名を関数のように使用することで。新しいインスタンスを生成することが出来る。
- 文字列はシングルクォート（'）で囲う
  - Pythonの場合、シングルクォート（'）/ダブルクォート（"）のいずれも動作するが、慣例的にシングルクォートの方がよく見かける。よって、本規約でも、原則としてシングルクォートを使用することとする。
- インスタンス変数へのアクセスはselfを使用する
  - Pythonの変数スコープについては「3.2.1.3 変数スコープ設計」にて説明したが、もう一つの概念として、「インスタンス変数」が存在する。インスタンス変数は、クラスに対して定義する変数であり、クラスから生成されたインスタンス毎に値を保持する。 一般的なオブジェクト指向言語では、インスタンス変数にアクセスする際は「this」を用いてアクセスするが、Pythonにおいては、「self」が用いられる。
  【Pythonにおけるインスタンス変数】
  ```python
  class Parent():
    def __init__(self, value=5):
      self.value = value
      print('super init')

  class SubClass(Parent):
    def __init__(self):
      super(__class__, self).__init__()
      print('sub init')
    
    def add(self, new_value):
      added_value = self.value + new_value
      print(added_value)
  # （続く）
  ```
  ```python
  #（続き）

  # メイン関数
  if __name__ == "__main__":
    hoge = SubClass()
    hoge.add(3)
  ```
  【サンプルコードの実行結果】
  ```
  super init
  sub init
  8
  ```
  上記のように、Pythonにおいては、クラスに対するインスタンス関数の第一引数に必ず「self」を定義し、__init__関数（コンストラクタ）などでselfに対して設定された変数が、「インスタンス変数」として扱われる。よって、Javaなどの「this」とは異なり、Pythonの場合、「selfを省略してインスタンス変数にアクセスする」といったようなことは、出来ない。
  逆に、インスタンス関数を呼び出す側は、上記サンプルコードのメイン関数のように、「self」は省略して関数を使用する。

## 3.4 コメントに関する指針/規約

### 3.4.1 コメントの種類と適用方針
| コメントの種類 | 代表的な記法 | 適用指針 |
| --- | --- | --- |
| ラインコメント | `# ...` | メソッド内では通常、このコメントを使用する。ラインコメント記号（#）と、コメント本体（...の部分）の間は、半角スペースを開け、コメント本体の文末には読点（。）はつけない。また、ラインコメントとソースコードの間には、空行は挿入してはならない。 |
| ブロックコメント | `''' ... '''` | シングルクォーテーション又はダブルクォーテーションを、三つ続ける。基本的には使用せず、複数行を一括してコメントアウトしたい場合は、VSCodeの機能（「Ctrl」+「/」 ）を利用する。 |
| docstringコメント | `""" ... """` | JavaにおけるJavaDocに相当する、ドキュメンテーション文字列（docstring）を記述する際に使用。ダブルクォーテーションを三つつなげる。詳細は、docstringに関する指針等々を参照。 |

### 3.4.2 コメント記述の前提
- コメントが不要、もしくは最小限になるコーディングを目標とする。
- 大量のコメントが必要なコードは、品質面の問題を抱えている場合が多いため、リファクタリングを強く推奨する。

### 3.4.3 コメント記述の規約
- 読点には「、」を使用し、「, 」は使用しない。
- 句点には「。」を使用し、「. 」は使用しない。
- 行末コメントは禁止。
  - 可読性が悪い他、VSCodeのオートインデント機能で意図しない整形が行われるため。
- docstringコメントの1行目は簡潔な文で記述し、読点で終える。
  - 1行目はAPIリファレンス出力時に概要として表示されるため、簡潔に記述する。

### 3.4.4 コメント記述の基本指針
- シンプル、かつ、最小限のコメント記述を心がける。
  - 大量のコメントは可読性を低下させるため、コメントを読まなくても理解できるシンプルなコードを目指す。
- 自明なコメントは書かない。
  - コードから内容が明らかな場合、コメントは不要。
- 「どのようにするか」ではなく「何をするか」を書く。
  - コメントには、そのコードで何を実現したいかを記述する。
  - 処理内容の詳細な説明が必要な場合は、コードのリファクタリングを推奨。
- 簡潔に、1行には一つのコマンドを書く。
  - 1行で多くの処理を行わず、3項演算子も原則禁止。
- ソースコード・ブロックごとに簡潔なコメント（ラインコメント）を記述し、ブロックの終わりには改行を入れる。
  - 1行ごとにコメントを記述したり、改行を入れずに次のブロックを記述したり、コメント無しでブロックを開始しない。
- エリア終了コメントが不要なコードを書く。
  - if文やfor文などの終了コメントが必要な場合は、処理領域が長すぎる・ネストが深すぎる等の問題があるため、リファクタリングを推奨。
- 変数／定数のコメントは1行で簡潔に記述する。
  - 変数／定数の名称で内容が明確に表現されているべきであり、コメントが必要な場合は名称のリファクタリングを推奨。
- 不要なコメントアウトは除去する。
  - コメントアウトされたコードが大量に存在すると可読性が低下するため、ごく一時的なものを除き、コメントアウトは除去する。

- 以下に、例としてコメントのサンプルを示す。
  【悪い例】
  ```python
  self._view = view
  self._model = self._view.model

  # イベントリスナ等の設定
  self._view.search_shoukyuu_shisuu_button.on_click(self.search_shoukyuu_shisuu)
  self._view.do_search_button.on_click(self.do_search)
  self._view.cancel_search_button.on_click(self.cancel_search)


  # サービス初期化
  self._service = ShoukyuuShisuuService(service_context)
  # 制度コード設定
  self._model.search.seidcode = CodeModel.seid_code.tekinen.code
  # 規約区分設定
  self._model.search.kiyaku_kubun = CodeModel.kiyaku_code.kari_kiyaku.code
  ```

  【良い例】
  ```python
  # イベントリスナ等の設定
  self._view = view
  self._model = self._view.model
  self._view.search_shoukyuu_shisuu_button.on_click(self.search_shoukyuu_shisuu)
  self._view.do_search_button.on_click(self.do_search)
  self._view.cancel_search_button.on_click(self.cancel_search)

  # サービス初期化
  self._service = ShoukyuuShisuuService(service_context)

  # 画面クリア
  self._model.search.seidcode = CodeModel.seid_code.tekinen.code
  self._model.search.kiyaku_kubun = CodeModel.kiyaku_code.kari_kiyaku.code
  ```

  - 以下に、良い例のポイントを示す。
    - コメントの目的は、「ソースコードの大まかな処理の流れ」を読者に伝えることであり、詳細な実装の説明や技術的な手順の羅列を行うものではない。
    - 変数の初期化など、大まかな流れの理解に関係しない処理については、コメントで逐一説明する必要はなく、処理のまとまりごとにコメントを添えるのが望ましい。
    - コメントとコードは交互に1行ずつ記述しないようにする。
    - コメントはコードブロックごとにまとめて記述し、コードブロックの間には1行の空行を入れることで、処理の流れが視覚的にも追いやすくなる。

### 3.4.5 docstringの基本指針
- docstringは、モジュール、クラス、関数（メソッド）に対して記述する。

#### 3.4.5.1 docstring記述のポイント
- 原則として、必須とする
  - ソースコード非公開の商用製品等とは異なり、業務プログラムはprotectedなものやprivateなものも全て保守・メンテナンス対象であり、技術的にprivateだからといって「非公開」なものでは無い。保守フェーズにおける可読性・メンテナンス性を考慮した場合、原則として、protectedやprivateであってもdocstringを記述することが望ましい。
  - 例外として1モジュール（1ファイル）に1クラスしか定義しない場合、モジュールのdocstringは省略可とし、クラスのdocstringのみでOKとする。
- Args:、Retruns:は必須とする。
  - それぞれ、JavaDocにおける「@param」「@return」に相当。ただし、パラメータや戻り値が無い場合の省略は、可とする。
- 特にキャッチして欲しい例外がある場合はRaises:を記載する。
  - JavaDocにおける「@throws」に相当する。Raises:の記載は必須とはしないが、特にキャッチして欲しい例外に関しては、記載を必須とする。即ち、関数を呼ぶ側は、Raises:の記載がある例外に関しては、Javaにおける検査例外と同等に扱い、決して無視しないこと。
- docstringの1行目は簡潔な1文コメントを入れ、必ず「。」（読点）で終える。
  - 説明が長くなる場合やソースコードの断片を記述したい場合は、2行目以降を記載する。ただし、そもそもの話として、説明が長くなるようなクラスやメソッドはなるべく作らないこと。
- 自動生成を活用する
  - 統一規格であるJavaのJavaDocとは異なり、Pythonのdocstringには、いくつかの流儀が存在する。本規約では、docstringの記述を効率化するため、VSCodeが自動生成するdocstringの流儀に、可能な限り従う。自動生成されない箇所に関しては、可能な限りPEP8及びEffective Pythonに従う。

## 3.5 フォーマットに関する規約/指針

### 3.5.1 全般的な規約
| 指針 | 説明 |
| --- | --- |
| 1行内の文字数 | 132文字 |
| タブ幅 | 半角空白2文字とする。 |
| タブの使用 | VSCode上では、特に制限を設けない。任意の箇所で使用可（VSCodeの設定により、タブ幅分の空白に置き換わる）。 |
| インデント | VSCodeのフォーマット機能を適用し、原則、タブによるインデントを行う。 |

### 3.5.2 フォーマットの成型
- 実装者はリポジトリにコミットする前に、Pylintのチェックエラー結果を解消すること。