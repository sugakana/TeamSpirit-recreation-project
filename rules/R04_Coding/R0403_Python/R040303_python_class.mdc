---
description: Pythonにおけるクラス設計の方針や命名規則に関する指針を定義するルール
globs: **/*.py
alwaysApply: false
---
# Python クラスに関する指針

このルールは、Pythonのクラス設計に関する指針を定義します。

Javaの場合、クラスに属さない関数や変数・定数は定義できないため、一口に「クラス」と言っても、大別して以下の三つの利用方法があった。

1. インスタンスを生成して利用するクラス
   - 通常通り、クラスからnew演算子でインスタンスを生成し、利用するクラス。昨今の業務システム開発では主に、DTOの作成に利用されることが多い。
2. staticメソッドのみが定義されたクラス
   - インスタンス化する必要がなく、「クラス名.関数名()」の形で直接関数を利用するクラス。主に、胸中のチェックロジックなどのユーティリティクラスを作成する際に、使用される。
3. シングルトンクラス
   - インスタンスが一つしか生成されないように制御されたクラス。2.のケースと同様、本来的にはインスタンス生成は不要であるが、「Springの機能を利用する」「環境に応じて処理を切り替えたい」などの、インスタンスを前提とした機能を利用したい場合などに、こういったデザインパターンが取られる。主に、業務ロジックやDAO（Data Access Object）の作成などに使用される。

以降、便宜上、1.を「通常クラス」（又は、単にクラス）、2.をstaticクラス（又は、ユーティリティクラス）、3.をシングルトンクラスと呼称する。

Pythonの場合、Javaと異なり、クラスに属さない関数や変数・定数も定義できるため、上記1.～3.を全てクラスで実現する必要はない。具体的に、本規約では、1.のみをクラスで実現し、2.・3.はモジュールつまり、Pythonファイルの中にクラスを定義せず、直接関数や変数・定数を定義する形で実現することを想定している。しかし、物理的な実体としてはモジュールとして実現する2.や3.も、疑似的にはJavaのクラスのように扱えるため、本省の規約は、1.～3.のすべてに適用されるものとする。

## 5.1 命名規約

### 5.1.1 クラス全般
- アッパーキャメルケースを使用すること
- 名詞を基本として命名すること
- シンプルで記述しやすい名前にすること
- 頭文字や省略文字の使用は避けること
- コンポーネント毎の命名規約に従うこと
  - サービス: 末尾に`Service`を付ける
  - DAO: 末尾に`Dao`を付ける
- クラス名に動詞を使用したくなった場合は、以下を検討すること：
  1. このクラスの本質的な目的は何か
  2. 動詞で表現したい機能は、メソッドとして実装すべきではないか

### 5.1.2 インターフェース
- Pythonには「インターフェース」という機構は存在しないが、全ての関数から「NotImplementedError」をスローするよう実装することにより、Javaの「インターフェース」敵に働くクラスを、疑似的に作成することができる。
- 疑似的なインターフェースクラスに関しては、以下の規約に従うこと。
  - クラス名と同様の指針で命名
  - `I`等の接頭辞は使用しない
  - マーカーインターフェースには`Able`接尾語を使用可
  - 実装クラスの命名規則：
    - 単一実装: `Default[インターフェース名]`
    - 複数実装: 実装内容を表す適切な接頭辞を使用

### 5.1.3 抽象クラス
- Pythonには「抽象クラス」という機構は存在しないが、一部の関数から「NotImplementedError」をスローするよう実装することにより、Javaの「抽象クラス」的に働くクラスを、疑似的に作成することは出来る。
- 疑似的な抽象クラスに関しては、以下の規約に従うこと。 
  - 抽象度に応じて以下の命名パターンを使用：
    | 抽象度 | 命名パターン | 使用例 |
    |--------|--------------|---------|
    | 高     | `Abstract[クラス名]` | `AbstractController` |
    | 中     | `Base[クラス名]` または `[クラス名]Base` | `BaseService`, `ControllerBase` |
    | 低     | `[クラス名]Support` | `ServiceSupport` |

## 5.2 設計に関する指針

### 5.2.1 基本指針
1. **単純で適切な責務**
   - クラスの責務を単純化すること
   - 適切な責務をクラスに割り当てること

2. **適切なメソッドとフィールド**
   - クラスの責務に対して適切なメソッドとフィールドを定義すること

3. **似たような概念の共通化**
   - 似通った責務を持つクラスは共通化・抽象化を検討
   - 親クラスの作成を検討

4. **重複の除去**
   - 共通化による重複処理の削減
   - 抽象化による重複処理の削減
   - 例：親クラスの作成、Utilクラスの作成

5. **クラス拡張の制限**
   - Pythonの場合、実装言語の機能にて拡張（継承）を制限することは出来ない。
   - 拡張を想定しないクラスは、staticクラスとして作成できないか、検討すること。

6. **共通化の方法は継承、委譲のどちらでも良い**
   - 継承方式：共通部を親クラスとして抽出
   - 委譲方式：共通部を別クラスとして切り出し
   - 原則として委譲方式を優先

7. **ステートレスクラスのシングルトン/ユーティリティクラス化**
   - 状態を持たないクラスはシングルトンまたはユーティリティクラス化
   - ユーティリティクラスは`final`として定義

8. **通常クラスの場合、ファイル名＝クラス名とする**
   - クラスを定義するためのファイル（モジュール）のファイル名（モジュール名）はネームスペースとして扱い、ネームスペース命名規約に従う。

9. **staticクラスの場合、ファイル名＝クラス名とする**
   - クラスを定義せず、直接関数を定義するためのファイル（モジュール）のファイル名（モジュール名）は、クラス名（staticクラス）として扱い、クラス命名規約に従う。

10. **シングルトンクラスの場合、ファイル名＝「クラス名 又は 変数名」とする**
   - モジュール（ファイル）の中にクラスを定義せず、直接関数を定義するが、Javaにおけるシングルトンクラス（例：Service、DAO等）のように振る舞うモジュールは、変数名的に扱う。

11. **通常クラスの場合、1ファイル＝複数クラスとする**
   - 1ファイル＝1クラスとした場合、1クラス毎にネームスペースが出来上がってしまうため、通常クラスの場合、ファイルもパッケージのように扱う。

12. **staticクラス・シングルトンクラスの場合、1ファイル＝1クラスとする**
   - 機構上、1ファイルに1クラス分しか定義できないため。

### 5.2.2 ファイル内の構成
- Pythonファイルは、上から順に、以下の順序で構成する。
  - 通常クラスの場合の記述順序
    | 順序 | 記述要素 |
    | --- | --- |
    | 1 | Import文 |
    | 2 | モジュールレベルの定数宣言（※1） |
    | 3 | クラス宣言（※2） |
    | 4 | クラスレベルの定数宣言（※1） |
    | 5 | クラス変数（※3） |
    | 6 | コンストラクタ |
    | 7 | インスタンスメソッド（※4） |
    | 8 | 関数宣言（※5） |

    ※1 各クラスに共通の内部定数のみ、pravateとして、モジュールレベルの定数宣言を許可する。publicとして公開する定数は、原則、クラスレベルの定数に定義すること。

    ※2 順序3～7の構成を繰り返し、複数定義することを許可する。

    ※3 Pythonの場合、インスタンス変数はコンストラクタ内でしか定義出来ず、クラス宣言の直下、メソッド定義と並列して定義した変数は、全てクラス変数となる。

    ※4 Pythonの場合、クラスメソッドは定義できない。クラス宣言の直下に定義する関数は、原則として、全てインスタンスメソッドになる。

    ※5 各クラスに共通の処理を「共通化」するための、プライベートな関数定義のみ、許可する。
  
  - staticクラス・シングルトンクラスの記述順序
    | 順序 | 記述要素 |
    | --- | --- |
    | 1 | Import文 |
    | 2 | 定数宣言 |
    | 3 | 変数宣言（※6） |
    | 4 | 関数宣言 |

    ※6 原則として、staticクラス・シングルトンクラスは、変数を定義しないこと。これらのクラスは変数即ち、「状態」を持たない（ステートレス）処理を作成することを目的としたデザインパターンであり、変数を持ちたい場合は、通常クラス化を検討すること。どうしてもstaticクラス・シングルトンクラスで変数を定義する必要がある場合は、ドキュメントをドキュメントを作成すること。

  - 同一レベルでアクセス可能性が異なる要素がある場合は、「public」「protected」「private」の順序で構成する（あくまでも疑似的なprivateであることに注意）

## 5.3 コメントに関する指針

### 5.3.1 docstringコメント
- 通常クラスとstaticクラス・シングルトンクラスでは記述方法が異なるためそれぞれ分けて説明する。

#### 5.3.1.1 通常クラスに対するdocstring
- テンプレートの利用方法
  - クラス定義の1行下で「"""」（ダブルクォーテーション三つ）を入力すると、「Generate Docstring」というメッセージが表示される。このとき、Enterキーを押下することにより、VSCodeがテンプレートを生成する。
  - 定義の中にドキュメンテーションコメントを記述する（これは、関数に対するdocstringでも同様）。

- 記述要素
  | 記述要素 | 必須 | 説明 |
  | --- | --- | --- |
  | [summary] | 〇 | 「"""」のすぐ横に自動生成される。簡潔な1文コメントを入れ、必ず「。」（読点）で終える。改行などは行わず、この位置（「"""」のすぐ横）から、1行記述すること。 |
  | [detatil] |  | 自動生成されない。[summary]では記述しきれない説明を記述したい場合に利用する。[summary]とArgsの間にそれぞれ空行を入れ、「"」と同じインデントで文を記述する。 |
  | Args: | (〇) | 親クラスが存在する場合、生成される。Args:は本来、関数の引数を記述するための記述子であるが、Pythonの構文上「ChildClass(ParanetClass)」のように、関数の引数的に親クラスを定義するため、このようなdocstringが生成される。[type]の部分には親クラスのクラス名をネームスペース含めて記述し、「:」の直後に改行を入れ、インデントさせて、[description]の部分に親クラスに対する説明を記述する。なお、親クラスの定義に限定していえば、[type]部分はそのままtypeになる（引数である親クラスのクラス情報は、Pythonの場合、type型となるため）。 |
  | Fields: | (〇) | インスタンス変数に対するdocstringを記述。自動生成されない。Pythonの場合、インスタンス変数に対するdocstringを記述する箇所がないため、クラスのdocstringにあわせて記述するものとする。記述フォーマットに関しては、Args:と同様 |

  【記述例】
  ```python
  class SomeClass(ResponseBuilder):
    """XXXをYYYするクラス。

    Args:
      ResponseBuilder (type):
        親クラス。
    
    Fields:
      status (int):
        ステータスコード。
    """

    def __init__(self):
      """初期処理。
      """
      self.status = 201
  ```

  - authorに関しては、記述しないものとする。

#### 5.3.1.2 staticクラス・シングルトンに対するdocstring
- テンプレートの利用方法
  - staticクラス・シングルトンクラスにおいては、ファイルの一番先頭で「"""」を入力し、docstringを生成する。

- 記述要素
  | 記述要素 | 必須 | 説明 |
  | --- | --- | --- |
  | [summary] | 〇 | 通常クラス同様。 |
  | [detail] |  | 通常クラス同様。 |
  | Functions: | 〇 | 利用可能なpublic関数を、以下の形式で記述する。<br><br>- 関数名:<br>&nbsp; 関数に対する1行コメント。 |

  【記述例】（LogUtilのdocstring）
  ```python
  """ログ出力用ライブラリ。

  ログレベルに応じて、ログの出力制御を行うためのライブラリ。
  環境変数に応じて、ログの内容をコンソールに出力するか、
  CloudWatchに出力するか、制御する。

  出力フォーマットは、以下に従う。

    [datetime](mdc:ISO書式) [level] loggerName - log \n

  Functions:
  - debug:
    デバッグレベルのログを出力する。

  - info:
    通知レベルのログを出力する。

  - warn:
    警告レベルのログを出力する。

  - audit:
    監査ログを出力する。

  - error:
    エラーレベルのログを出力する。

  - timeout:
    タイムアウト時のエラーログを出力する
  """
  ```