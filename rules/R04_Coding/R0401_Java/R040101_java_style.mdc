---
description: Javaの命名規則とコーディングスタイルの基本ガイドラインを定義するルール
globs: src/**/*.java
alwaysApply: false
---
# Java命名規則・スタイルガイド

このルールは、Javaファイルの命名規則およびスタイルガイドの基本をまとめたものです。

## 適用範囲
- `src/**/*.java`配下の全Javaファイル

## 3.1 Java命名規約

このルールは、Java開発における命名規約の詳細を定めます。

### 3.1.1 ハンガリアン記法について
- 原則としてハンガリアン記法は採用しません。
- 採用しない理由：
  - Javaでは全ての型の略語を管理するのは不可能であり、プレフィックス付加を徹底できないため。
  - 変数のスコープは最小限に設定され、IDE等で型の判断が容易なため。
  - 特定のコンポーネントにプレフィックス・サフィックスを付けたい場合は、後述の命名指針でカバー可能なため。
- ※ハンガリアン記法とは、変数の型・役割を略語化し、プレフィックスとして変数名に組み入れる記法です。

### 3.1.2 命名に関する基本指針
- 正しくフルスペルで変数/フィールド/クラス等を命名する。
  - 例：firstName, grandTotal, CorporateCustomer
  - x1, y1, fnのような意味不明な略称は避ける。
- 業務分野の用語を適切に使用する。
  - 例：顧客を「Customer」と定義している場合、Client等の別単語は使わない。
- 略語は控えめにし、使用する場合は統一する。
  - 例：numberの省略形はnum等、標準リストを作成し一貫して使用。
- あまりに長すぎる名前は避ける（目安：15文字以下）。
- ほんの些細な違いしかない名前は使用しない。
  - 例：anSqlDatabase, anSQLDatabase
- 標準的な略語は、属性名は小文字始まり、クラス名は先頭のみ大文字。
  - 例：sqlDataBase（属性）、SqlDatabase（クラス）
- RDBMSのテーブル項目名称はそのまま使用し、独自の英単語やローマ字は定義しない。
- 上記以外の専門用語はヘボン式ローマ字を使用。
- 上記以外の一般的な単語は平易な英単語を使用。

### 3.1.3 使用可能な文字
- 半角英数字およびアンダースコア（_）

### 3.1.4 命名スタイル
| スタイル | 説明 | 例 |
|---|---|---|
| アッパーキャメルケース（パスカルケース） | 単語先頭大文字 | UserInfo, MessageUtil |
| ローワーキャメルケース（キャメルケース） | 先頭単語のみ小文字、以降は単語先頭大文字 | value, maxLength |
| スネークケース | 全て大文字、単語区切りにアンダースコア | CHAR_LENGTH |
| ローワースネークケース | 全て小文字、単語区切りにアンダースコア | char_length |

## 3.2 設計に関する指針

### 3.2.1 スコープ設計

#### 3.2.1.1 スコープ設計の基本指針
- クラス／メソッド／フィールドのアクセス可能性や変数のスコープは、可能な限り最小限となるように設計する。
- 可能な限り狭いスコープで設計すること。

#### 3.2.1.2 アクセス可能性の設計
- アクセス修飾子は、基本的に`private`を優先し、必要に応じてスコープを広げる。
- Javaにおけるアクセス可能性の優先順位は以下の通り：
  1. private
  2. 指定なし（パッケージプライベート）
  3. protected
  4. public

#### 3.2.1.3 変数スコープ設計
- 変数の有効スコープは、可能な限り狭く設定する。
- 変数は「使用する直前」で宣言する。
  - 例：メソッド内の途中で使う変数は、メソッドの先頭ではなく、その変数を使用する直前で宣言する。
  - 定義箇所と使用箇所を同じブロックにすることで、意図が明確になり、変数名の競合エラーも防げる。
- 変数は「使用するブロック内」で宣言する。
  - 例：メソッド内で使う変数はそのメソッド内で、さらに特定のブロックで使う場合はそのブロック内で宣言する。
- ブロック（try-catch, if, for, while等、{}で囲われる範囲）を意識して変数スコープを設計する。

## 3.3 実装に関する指針

### 3.3.1 宣言

#### 3.3.1.1 型宣言
- 型宣言が可能な全ての場所で型宣言を必須とする（省略不可）。
  - 変数、戻り値、ジェネリックパラメータ等、型宣言が可能な全ての場所で必ず型を明示する。
- 配列を参照する変数／定数は「型[]」形式で型宣言を行う。
  - 例：○ String[] args　× String args[]
  - 配列の使用は可能な限り避け、List等のCollection型の利用を推奨。

#### 3.3.1.2 その他の宣言
- 不要なimport宣言は書かない（存在する場合は除去する）。
  - 不要なimport文はIDEの機能（例：EclipseはCtrl+Shift+O）で整理可能。
- ワイルドカード（*）を使用したimport宣言は禁止。

### 3.3.2 初期化

#### 3.3.2.1 変数の初期化
- 暗黙的に設定される初期値を意識してコーディングする。
  - Javaでは、メソッド内のローカル変数には暗黙的な初期化は適用されない。
- Javaにおける暗黙的な初期値：
  - 数値型（short, byte, int, long, char, float, double）：0
  - 論理値型（Boolean）：false
  - 参照型：null

#### 3.3.2.2 コンストラクタ
- 暗黙的なコンストラクタの追加を意識する。
  - クラスにコンストラクタが定義されていない場合、デフォルトコンストラクタ（引数なし）が自動追加される。
  - 引数有りコンストラクタを明示的に定義した場合、デフォルトコンストラクタは自動追加されない。
- 暗黙的な親クラスのコンストラクタ呼び出しを意識する。
  - コンストラクタ内で明示的に親クラスのコンストラクタを呼び出さない場合、同じ引数の親クラスのコンストラクタが自動的に呼び出される。
- staticクラス（ユーティリティクラス）のコンストラクタはprivate化し、インスタンス化不可とする。

### 3.3.3 判定分（if,forなど）

#### 3.3.3.1 無駄なelseの除去
- 不必要なelse文節がある場合は、else文節を除去して見通しを良くする。

【修正前】無駄なelse文節がある判定文:
```java
//無駄なelseがある判定文
public int sampleMethod(int i) {
  if (i == 1) {
    return i;
  } else {
    return 2;
  }
}
```

【修正後】無駄なelse文節を除去して見通しを良くした判定文:
```java
public int sampleMethod(int i) {
  if (i == 1) {
    return i;
  }
  return 2;
}
```

#### 3.3.3.2 条件判定の反転
- 判定文内のブロックが長い、または、判定文内のネスト構造が深い等の問題は、条件判定の斑点を利用して、見通しを良くする。

【修正前】長いネストされたブロックがある判定文:
```java
public int sampleMethod(int i, boolean expression) {
  int j = 0;
  if (expression) {
    // 処理
    // 処理
    // 処理
    // 処理
    // 処理
  } else {
    j = i;
  }
  return j;
}
```

【修正後】条件判定を反転してネストを除去し、同時にブロックを短くした判定文:
```java
public int sampleMethod(int i, boolean expression) {
  if (!(expression)) {
    return i;
  }

  // 処理実行
  int j = 0;
  // 処理
  // 処理
  // 処理
  // 処理
  // 処理
  return j;
}
```

#### 3.3.3.4 組み合わせ判定のメソッド化
- 条件判定が複雑な組み合わせによって構成される場合は、メソッド化して見やすくする。
- メソッドは何を判定しているか分かる適せるな関数名を利用する。

【修正前】複雑な条件判定の組み合わせがある判定文:
```java
public int sampleMethod(boolean a, boolean b, boolean c) {
  if (a && (b || c)) {
    return 1;
  } else if ((a || b) && c) {
    return 2;
  }
  return 3;
}
```

【修正後】複雑な条件判定の組み合わせをメソッド化した判定文:
```java
public int sampleMethod(boolean a, boolean b, boolean c) {
  if (isSomething(a, b, c)) {
    return 1;
  } else if (isOther(a, b, c)){
    return 2;
  }
  return 3;
}
```

### 3.3.4 エラー処理

#### 3.3.4.1 例外処理
- 検査例外と非検査例外を意識して使用/処理する
  - 検査例外は、システムによって想定され、アプリケーションでの対処を必要とする、リカバリが可能な例外である。非検査例外は、システムによって想定されない、アプリケーションでのリカバリが不可能な例外である。これらを理解した上で、例外のスロー、ならびに、例外の処理を適切に行う。
- 例外のキャッチはサブ例外クラスから優先的に行う
  - ある例外と、それを継承したサブ例外を個別に処理する場合、サブ例外よりも先に親例外をキャッチしてしまうと、サブ例外に対する処理が隠蔽されてしまう。この様な場合、サブ例外を先にキャッチするように記述しなければならない。
- 例外を隠蔽しない
  - キャッチした例外は、必ず処理しなければならない。そうで無い場合は、そのままリスローし、システム共通の例外処理に任せる。
- 検査例外を無視しない
  - 検査例外は、例外発生時において、なんらかの対処がなされるべき例外である。したがって、それを無視してはならない。検査例外の再スローを行う場合は、理由や影響範囲を十分に検討し、問題がない場合にのみ行う。
- キャッチすべきでない例外を不正にキャッチしない
  - フレームワークによって対処される例外等を、アプリケーションでむやみにキャッチしない。フレームワークのデフォルトの例外処理を拡張したいなどの明確な理由がある場合にのみキャッチし、そうでない場合は、仮にキャッチしたとしても、再スローする。
- 例外を正常な状況で使用しない
  - 例外クラスは、あくまで「例外」であり、処理に必要なコストも高く、パフォーマンスも劣化する。正常処理にて予想される事象に対して例外を利用してはならない。
  - 例えば、nullである可能性が予め分かっているならば、以下のように例外をtry/catchするのではなく、nullチェックを行う。
  
  【悪い例】あらかじめ分かっているのに、例外の機構を利用してnullチェックする:
  ```java
  public void sampleMethod(String[] args) {
    int i = 0;
    boolean exitFlag = false;
    while (!exitFlag) {
      try {
        System.out.println(args[i]);
        i += 1;
      } catch (IndexOutOfBoundsException e) {
        exitFlag = true;
      }
    }
  }
  ```

  【良い例】あらかじめ分かっている場合は、きちんとnullチェックを行う:
  ```java
  public void sampleMethod(String[] args) {
    for (int i = 0; i < args.length; i++) {
      System.out.println(args[i]);
    }
  }
  ```

- finally句でreturnやthrowをしない
  - finally句で値を戻したり例外のスローを行うと、tryブロック内で発生した例外が失われてしまう。
  ```java
  public void sampleMethod(String[] args) {
    try {
      throw new NullPointerException();
    } finally {
      return 2;
    }
  }
  ```

#### 3.3.4.2 独自例外の作成について
- 体系化された例外クラスを活用し、むやみに独自の例外クラスを定義しない

### 3.3.5 その他
- null、および、NullPointerExceptionについて考慮する。
  - null、および、NullPointerExceptionは非常に忘れられ易く、バグの原因となり易い。変数やメソッドの戻り値がnullである可能性、および、NullPointerExceptionに対し、常に考慮すること。
- マジックナンバーは列挙型化／定数化する。
  - 区分値（1：本社、2：○○事業所、3：××営業所）等の、数値自体に意味がある、いわゆるマジックナンバーについては、可読性や保守性の観点から、定数、あるいは、列挙型として定義すること。
- 変数の読み替えないをしない
  - 状況によって異なる対象を、１つの変数に格納し、状況によって読み替えて使用してはならない。このような変数の読み替えは、可読性や保守性を低下させる。変数は、同じ対象を指し示すものとして、定義すること。
- 複雑な文字列連結には、「+」演算子ではなくStringBuilderを使う。
  - ループ処理内での文字列連結や、複数行にまたがる文字列連結において、文字列連結に「+」演算子を使用すると、パフォーマンスに悪影響を及ぼす。そのような場合は、StringBuilderを使用すること。ただし、１行内に納まる単純な文字列連結の場合は、コンパイラによる最適化が働くため、可読性の観点から、「+」演算子を使用しても良い。
- ローカル変数によるフィールド変数の隠蔽を意識する
  - ローカル変数でフィールド変数と同名の変数を定義した場合、そのローカル変数が有効な範囲内において、フィールド変数は隠蔽され、thisを用いない限り参照することはできなくなる。よって、setterメソッド等の自動生成されるメソッドをそのまま利用するケースでもない限り、原則として、メソッドの引数を含むローカル変数名にはフィールド変数名とは異なる名前をつけるものとする。
  - どうしてもフィールド変数とローカル変数を同名にしなければならない場合に限り、this修飾子を用いてフィールド変数とローカル変数を区別するものとする。

## 3.4 コメントに関する指針/規約

### 3.4.1 コメントの種類と適用方針
- ラインコメント
  - メソッド内では通常、このコメントを使用する。ラインコメント記号（//）と、コメント本体（...の部分）の間は、半角スペースを開け、コメント本体の文末には読点（。）はつけない。また、ラインコメントとソースコードの間には、空行は挿入してはならない。
- ブロックコメント
  - 基本的には使用せず、複数行を一括してコメントアウトしたい場合に使用する。
- JavaDocDocコメント
  - JavaDocに関する指針等々を参照

### 3.4.2 コメント記述の前提
- コメントが不要、もしくは最小限になるコーディングを目標とする。
- 大量のコメントが必要なコードは、品質面の問題を抱えている場合が多いため、リファクタリングを強く推奨する。

### 3.4.3 コメント記述の規約
- 読点には「、」を使用し、「, 」は使用しない。
- 句点には「。」を使用し、「. 」は使用しない。
- 行末コメントは禁止。
  - 可読性が悪くなり、オートインデント機能で意図しない整形が行われるため。
- JavaDocコメントの1行目は簡潔な文で記述し、読点で終える。
  - 1行目はAPIリファレンス出力時に概要として表示されるため、簡潔に記述する。

### 3.4.4 コメント記述の基本指針
- シンプル、かつ、最小限のコメント記述を心がける。
  - 大量のコメントは可読性を低下させるため、コメントを読まなくても理解できるシンプルなコードを目指す。
- 自明なコメントは書かない。
  - コードから内容が明らかな場合、コメントは不要。
- 「どのようにするか」ではなく「何をするか」を書く。
  - コメントには、そのコードで何を実現したいかを記述する。
  - 処理内容の詳細な説明が必要な場合は、コードのリファクタリングを推奨。
- 簡潔に、1行には一つのコマンドを書く。
  - 1行で多くの処理を行わず、3項演算子も原則禁止。
- ソースコード・ブロックごとに簡潔なコメント（ラインコメント）を記述し、ブロックの終わりには改行を入れる。
  - 1行ごとにコメントを記述したり、改行を入れずに次のブロックを記述したり、コメント無しでブロックを開始しない。
- エリア終了コメントが不要なコードを書く。
  - if文やfor文などの終了コメントが必要な場合は、処理領域が長すぎる・ネストが深すぎる等の問題があるため、リファクタリングを推奨。
- 変数／定数のコメントは1行で簡潔に記述する。
  - 変数／定数の名称で内容が明確に表現されているべきであり、コメントが必要な場合は名称のリファクタリングを推奨。
- 不要なコメントアウトは除去する。
  - コメントアウトされたコードが大量に存在すると可読性が低下するため、ごく一時的なものを除き、コメントアウトは除去する。

- 以下に、例としてコメントのサンプルを示す。
  【悪い例】
  ```java
  _view = (ShoukyuuShisuuSearchView)(view);
  _model = _view.model;

  // イベントリスナ等の設定
  addEventListener(_view.searchShoukyuuShisuu, MouseEvent.CLICK, searchShoukyuuShisuu);
  addEventListener(_view.doSearch, MouseEvent.CLICK, doSearch);
  addEventListener(_view.cancelSearch, MouseEvent.CLICK, cancelSearch);


  // サービス初期化
  _service = new ShoukyuuShisuuService(serviceContext);
  // 制度コード設定
  _view.model.search.seidcode    = CodeModel.seidCode.tekinen.code;
  // 規約区分設定
  _view.model.search.kiyakuKubun = CodeModel.kiyakuCode.kariKiyaku.code;
  ```

  【良い例】
  ```java
  // イベントリスナ等の設定
  _view = (ShoukyuuShisuuSearchView)(view);
  _model = _view.model;
  addEventListener(_view.searchShoukyuuShisuu, MouseEvent.CLICK, searchShoukyuuShisuu);
  addEventListener(_view.doSearch, MouseEvent.CLICK, doSearch);
  addEventListener(_view.cancelSearch, MouseEvent.CLICK, cancelSearch);

  // サービス初期化
  _service = new ShoukyuuShisuuService(serviceContext);

  // 画面クリア
  _view.model.search.seidcode    = CodeModel.seidCode.tekinen.code;
  _view.model.search.kiyakuKubun = CodeModel.kiyakuCode.kariKiyaku.code;
  ```

  - 以下に、良い例のポイントを示す。
    - コメントの目的は、「ソースコードの大まかな処理の流れ」を読者に伝えることであり、詳細な実装の説明や技術的な手順の羅列を行うものではない。
    - 変数の初期化など、大まかな流れの理解に関係しない処理については、コメントで逐一説明する必要はなく、処理のまとまりごとにコメントを添えるのが望ましい。
    - コメントとコードは交互に1行ずつ記述しないようにする。
    - コメントはコードブロックごとにまとめて記述し、コードブロックの間には1行の空行を入れることで、処理の流れが視覚的にも追いやすくなる。

### 3.4.5 JavaDocの基本指針
- JavaDocは、クラス、関数（メソッド）、プロパティ（インスタンス変数／定数、static変数／定数）に対して記述する。

#### 3.4.5.1 JavaDoc記述のポイント
- Javaソースファイルには、JavaDoc形式のコメントを記述し、JavaDocを作成すること。
- JavaDocコメントの記述は原則必須とする。
  - protectedやprivateであっても、保守・メンテナンス性向上のため、JavaDocを記述することが望ましい。
- `@param`、`@return`、`@throws`は必須（該当しない場合は省略可）。
- JavaDocの1行目は簡潔な1文コメントを記述し、必ず「。」（句点）で終える。
  - 説明が長くなる場合やソースコード断片を記述したい場合は、HTMLタグを使用する。
  - ただし、説明が長くなるクラスやメソッド自体をなるべく作らないこと。

## 3.5 フォーマットに関する規約／指針

### 3.5.1 全般的な規約
- 1行内の文字数は132文字以内とする。
- タブ幅は半角空白4文字とする。
- タブの使用は任意とし、特に制限を設けない。
- インデントはEclipseのフォーマット機能を適用し、原則タブによるインデントを行う。

### 3.5.2 フォーマットの整形
- フォーマットはIDEの自動整形機能を利用する。
- 実装者はリポジトリにコミットする前に、IDEのフォーマット機能でコード整形を行うこと。
- ただし、IDEのフォーマット設定が未設定の場合は、目視・コードレビューで確認し、IDEのフォーマット機能は利用しない。

### 3.5.3 記述順序
- Javaファイルは、以下の順序で記述する。
  1. Package文
  2. Import文
  3. クラス宣言
  4. 定数宣言
  5. クラス変数
  6. インスタンス変数
  7. デフォルトコンストラクタ
  8. 引数有りのコンストラクタ
  9. アクセッサメソッド（getter/setter）
  10. クラスメソッド
  11. メソッド
- 同一レベルでアクセス修飾子が異なる要素がある場合は、「public」「protected」「修飾子なし」「private」の順で記述する。
- アクセッサメソッドは、プロパティ毎にgetter/setterの順に記述する。

## 3.6 修飾子の記述順
- 各宣言に付与する修飾子は、Java言語の仕様に則り、以下の順で記述する。
  1. アクセス修飾子（public / protected / private）
  2. abstract
  3. static
  4. final
  5. transient
  6. volatile
  7. synchronized
  8. native
  9. strictfp



