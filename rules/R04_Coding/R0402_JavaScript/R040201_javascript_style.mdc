---
description: JavaScriptおよびVue.jsプロジェクトにおける基本的なコーディング規約とスタイルガイドを定義するルール
globs: src/**/*.js,src/**/*.vue
alwaysApply: false
---
# JavaScript/Vue.js コーディング規約・スタイルガイド

このルールは、JavaScriptおよびVue.jsプロジェクトのコーディング規約およびスタイルガイドの基本をまとめたものです。

## 適用範囲
- `src/**/*.js`配下の全JavaScriptファイル
- `src/**/*.vue`配下の全Vue.jsファイル

## 3.1 JavaScript命名規約

このルールは、JavaScript開発における命名規約の詳細を定めます。

### 3.1.1 ハンガリアン記法について
- 原則としてハンガリアン記法は採用しません。
- 採用しない理由：
  - JavaScriptでは全ての型の略語を管理するのは不可能であり、プレフィックス付加を徹底できないため。
  - 変数のスコープは最小限に設定され、IDE等で型の判断が容易なため。
  - 特定のコンポーネントにプレフィックス・サフィックスを付けたい場合は、後述の命名指針でカバー可能なため。
- ※ハンガリアン記法とは、変数の型・役割を略語化し、プレフィックスとして変数名に組み入れる記法です。

### 3.1.2 命名に関する基本指針
- 正しくフルスペルで変数/フィールド/クラス等を命名する。
  - 例：firstName, grandTotal, CorporateCustomer
  - x1, y1, fnのような意味不明な略称は避ける。
- 業務分野の用語を適切に使用する。
  - 例：顧客を「Customer」と定義している場合、Client等の別単語は使わない。
- 略語は控えめにし、使用する場合は統一する。
  - 例：numberの省略形はnum等、標準リストを作成し一貫して使用。
- あまりに長すぎる名前は避ける（目安：15文字以下）。
- ほんの些細な違いしかない名前は使用しない。
  - 例：anSqlDatabase, anSQLDatabase
- 標準的な略語は、属性名は小文字始まり、クラス名は先頭のみ大文字。
  - 例：sqlDataBase（属性）、SqlDatabase（クラス）
- RDBMSのテーブル項目名称はそのまま使用し、独自の英単語やローマ字は定義しない。
- 上記以外の専門用語はヘボン式ローマ字を使用。
- 上記以外の一般的な単語は平易な英単語を使用。

### 3.1.3 使用可能な文字
- 半角英数字およびアンダースコア（_）

### 3.1.4 命名スタイル
| スタイル | 説明 | 例 |
|---|---|---|
| アッパーキャメルケース（パスカルケース） | 単語先頭大文字 | UserInfo, MessageUtil |
| ローワーキャメルケース（キャメルケース） | 先頭単語のみ小文字、以降は単語先頭大文字 | value, maxLength |
| スネークケース | 全て大文字、単語区切りにアンダースコア | CHAR_LENGTH |
| ローワースネークケース | 全て小文字、単語区切りにアンダースコア | char_length |

## 3.2 設計に関する指針

### 3.2.1 スコープ設計

#### 3.2.1.1 スコープ設計の基本指針
- クラス／メソッド／フィールドのアクセス可能性や変数のスコープは、可能な限り最小限となるように設計する。
- 可能な限り狭いスコープで設計すること。

#### 3.2.1.2 アクセス可能性の設計
- JavaScriptではアクセス修飾子の代わりに命名規約を用いてアクセス可能性を設計する。
- 基本的にprivate（非公開）を優先し、必要に応じてスコープを広げる。
- JavaScriptにおけるアクセス可能性の優先順位は以下の通り：
  | 優先順位 | 命名規約 | アクセス可能性 |
  |---|---|---|
  | 1 | 「_」で始まる | private |
  | 2 | 「_」で始まらない | public |

#### 3.2.1.3 変数スコープ設計
- 変数の有効スコープは、可能な限り狭く設定する。
- 変数は「使用する直前」で宣言する。
  - 例：メソッド内の途中で使う変数は、メソッドの先頭ではなく、その変数を使用する直前で宣言する。
  - 定義箇所と使用箇所を同じブロックにすることで、意図が明確になり、変数名の競合エラーも防げる。
- 変数は「使用するブロック内」で宣言する。
  - 例：メソッド内で使う変数はそのメソッド内で、さらに特定のブロックで使う場合はそのブロック内で宣言する。
- ブロック（try-catch, if, for, while等、{}で囲われる範囲）を意識して変数スコープを設計する。
- 変数はletで定義する。
  - varはスコープ単位で曖昧になりやすいため、使用禁止とする。

## 3.3 実装に関する指針

### 3.3.1 宣言

#### 3.3.1.1 型宣言
- JavaScriptにおいては、原則として、型宣言を行うことはできない。よって、型宣言は省略可とする。

#### 3.3.1.2 その他の宣言
- 不要なimport宣言は書かない（存在する場合は除去する）。

### 3.3.2 初期化

#### 3.3.2.1 変数の初期化
- 暗黙的に設定される初期値を意識してコーディングする。
  - JavaScriptでは、変数に対して明示的に初期化がなされない場合は、暗黙的な初期化は行われず、全て「undefined」として定義される。
- undefinedは明示的に代入しない。
  - 見初期化を明示的に代入する場合は、undefinedではなく、nullを代入する。
- 変数が未初期化かどうかを判定する場合は、

#### 3.3.2.2 コンストラクタ
- JavaScriptにおいて、「コンストラクタ」という機構は存在しない。よって、コンストラクタに関する規約は存在しない。

### 3.3.3 判定分（if,forなど）

#### 3.3.3.1 厳密判定の利用
- 原則、曖昧判定（==, !=）ではなく、厳密判定（===, !==）を利用する。

【曖昧判定】
```javascript
if ("1" == 1) {
  // 通常のプログラミング言語の場合はfalseになるが、JavaScriptの場合はtrueになる
}
```

【厳密判定】
```javascript
if ("1" === 1) {
  // 通常のプログラミング言語の「==」とほぼ近い動作をする。
}
```

#### 3.3.3.2 無駄なelseの除去
- 不必要なelse文節がある場合は、else文節を除去して見通しを良くする。

【修正前】無駄なelse文節がある判定文:
```javascript
//無駄なelseがある判定文
function sampleMethod(i) {
  if (i === 1) {
    return i;
  } else {
    return 2;
  }
}
```

【修正後】無駄なelse文節を除去して見通しを良くした判定文:
```javascript
function sampleMethod(i) {
  if (i === 1) {
    return i;
  }
  return 2;
}
```

#### 3.3.3.3 条件判定の反転
- 判定文内のブロックが長い、または、判定文内のネスト構造が深い等の問題は、条件判定の斑点を利用して、見通しを良くする。

【修正前】長いネストされたブロックがある判定文:
```javascript
function sampleMethod(i, expression) {
  let j = 0;
  if (expression) {
    // 処理
    // 処理
    // 処理
    // 処理
    // 処理
  } else {
    j = i;
  }
  return j;
}
```

【修正後】条件判定を反転してネストを除去し、同時にブロックを短くした判定文:
```javascript
function sampleMethod(i, expression) {
  if (!expression) {
    return i;
  }

  // 処理実行
  let j = 0;
  // 処理
  // 処理
  // 処理
  // 処理
  // 処理
  return j;
}
```

#### 3.3.3.4 組み合わせ判定のメソッド化
- 条件判定が複雑な組み合わせによって構成される場合は、メソッド化して見やすくする。
- メソッドは何を判定しているか分かる適せるな関数名を利用する。

【修正前】複雑な条件判定の組み合わせがある判定文:
```javascript
function sampleMethod(a, b, c) {
  if (a && (b || c)) {
    return 1;
  } else if ((a || b) && c) {
    return 2;
  }
  return 3;
}
```

【修正後】複雑な条件判定の組み合わせをメソッド化した判定文:
```javascript
function sampleMethod(a, b, c) {
  if (isSomething(a, b, c)) {
    return 1;
  } else if (isOther(a, b, c)){
    return 2;
  }
  return 3;
}
```

### 3.3.4 エラー処理

#### 3.3.4.1 例外処理
- 全て、非検査例外である
  - Javaのような、必ずcatchしなければならない「検査例外」と、catch不要の「非検査例外」には分かれていない。よって、利用者にcatchして欲しい例外をスローする場合は、特にJSDocに明記する必要がある。
- 例外のキャッチはサブ例外クラスから優先的に行う
  - ある例外と、それを継承したサブ例外を個別に処理する場合、サブ例外よりも先に親例外をキャッチしてしまうと、サブ例外に対する処理が隠蔽されてしまう。この様な場合、サブ例外を先にキャッチするように記述しなければならない。
- 例外を隠蔽しない
  - キャッチした例外は、必ず処理しなければならない。そうで無い場合は、そのままリスローし、システム共通の例外処理に任せる。
- キャッチすべきでない例外を不正にキャッチしない
  - フレームワークによって対処される例外等を、アプリケーションでむやみにキャッチしない。フレームワークのデフォルトの例外処理を拡張したいなどの明確な理由がある場合にのみキャッチし、そうでない場合は、仮にキャッチしたとしても、再スローする。
- 例外を正常な状況で使用しない
  - 例外クラスは、あくまで「例外」であり、処理に必要なコストも高く、パフォーマンスも劣化する。正常処理にて予想される事象に対して例外を利用してはならない。
  - 例えば、nullである可能性が予め分かっているならば、以下のように例外をtry/catchするのではなく、nullチェックを行う。
  
  【悪い例】あらかじめ分かっているのに、例外の機構を利用してnullチェックする:
  ```javascript
  /**
   * ある関数。
   *
   * @param {?} foo ある連想配列。
   */
  app.data_set.table.SomeClass.prototype.someFunc = function (foo) {
    var bar;
    try {
      bar = foo.bar.someProperty;
    } catch (e) {
      bar = null;
    }
  }
  ```

  【良い例】あらかじめ分かっている場合は、きちんとnullチェックを行う:
  ```javascript
  /**
   * ある関数。
   *
   * @param {?} foo ある連想配列。
   */
  app.data_set.table.SomeClass.prototype.someFunc = function (foo) {
    var bar;
    if (foo.bar) {
      bar = foo.bar.someProperty;
    } else {
      bar = null;
    }
  }
  ```

- finally句でreturnやthrowをしない
  - finally句で値を戻したり例外のスローを行うと、tryブロック内で発生した例外が失われてしまう。
  ```javascript
  /**
   * ある関数。
   *
   * @returns {number|null} 戻り居。
   */
  app.data_set.table.SomeClass.prototype.someFunc = function () {
    try {
      new TypeError();
    } finally {
      return 2;
    }
  }
  ```

#### 3.3.4.2 独自例外の作成について
- 体系化された例外クラスを活用し、むやみに独自の例外クラスを定義しない。

### 3.3.5 その他
- null、および、Null参照について
  - Null参照、いわゆる、JavaにおけるNullPointerExceptionが発生するケースでは、JavaScriptにおいては、「TypeError」というエラークラスが発生する。null、および、Null参照は非常に忘れられ易く、バグの原因となり易い。変数やメソッドの戻り値がnull（又は、undefined）である可能性、および、Null参照に対し、常に考慮すること。
- マジックナンバーは列挙型化／定数化する。
  - 区分値（1：本社、2：○○事業所、3：××営業所）等の、数値自体に意味がある、いわゆるマジックナンバーについては、可読性や保守性の観点から、定数定義すること。
- 変数の読み替えないをしない
  - 状況によって異なる対象を、１つの変数に格納し、状況によって読み替えて使用してはならない。このような変数の読み替えは、可読性や保守性を低下させる。変数は、同じ対象を指し示すものとして、定義すること。
- 文字列連結における「+」演算子について
  - Javaと異なり、JavaScriptにおいては、文字列連結時に「+」演算子を用いても問題無い（より高速化する手法として、Arrayのjoin()関数を利用する方法も、存在する）。
- コールバック処理にはアロー関数を使用する
  -基本、無名関数は使用しない
  【悪い例】無名関数を利用したコールバック処理
  ```javascript
  // サーバーアクセス
  var that = this;
  that.callService(url, param, function (data, response) {
    // 編集対象のデータが存在しなかった場合
    if (!data) {
      let msg = that.getMessage('E00005');
      that.showError(msg);
      that.$router.push({ path: '/customerEntryMain?mode=back' });
    }

    // 取得したデータをセット
    that.setData('data', data);
  });
  ```

  【良い例】アロー関数を利用したコールバック処理
  ```javascript
  this.callService(url, param, (data, response) => {
    // 編集対象のデータが存在しなかった場合
    if (!data) {
      let msg = this.getMessage('E00005');
      this.showError(msg);
      this.$router.push({ path: '/customerEntryMain?mode=back' });
    }

    // 取得したデータをセット
    this.setData('data', data);
  });
  ```

## 3.4 コメントに関する指針/規約

### 3.4.1 コメントの種類と適用方針
- ラインコメント
  - メソッド内では通常、このコメントを使用する。ラインコメント記号（//）と、コメント本体（...の部分）の間は、半角スペースを開け、コメント本体の文末には読点（。）はつけない。また、ラインコメントとソースコードの間には、空行は挿入してはならない。
- ブロックコメント
  - 基本的には使用せず、複数行を一括してコメントアウトしたい場合に使用する。
- JSDocコメント
  - JSDocに関する指針等々を参照

### 3.4.2 コメント記述の前提
- コメントが不要、もしくは最小限になるコーディングを目標とする。
- 大量のコメントが必要なコードは、品質面の問題を抱えている場合が多いため、リファクタリングを強く推奨する。

### 3.4.3 コメント記述の規約
- 読点には「、」を使用し、「, 」は使用しない。
- 句点には「。」を使用し、「. 」は使用しない。
- 行末コメントは禁止。
  - 可読性が悪くなり、オートインデント機能で意図しない整形が行われるため。
- JSDocコメントの1行目は簡潔な文で記述し、読点で終える。
  - 1行目はAPIリファレンス出力時に概要として表示されるため、簡潔に記述する。

### 3.4.4 コメント記述の基本指針
- シンプル、かつ、最小限のコメント記述を心がける。
  - 大量のコメントは可読性を低下させるため、コメントを読まなくても理解できるシンプルなコードを目指す。
- 自明なコメントは書かない。
  - コードから内容が明らかな場合、コメントは不要。
- 「どのようにするか」ではなく「何をするか」を書く。
  - コメントには、そのコードで何を実現したいかを記述する。
  - 処理内容の詳細な説明が必要な場合は、コードのリファクタリングを推奨。
- 簡潔に、1行には一つのコマンドを書く。
  - 1行で多くの処理を行わず、3項演算子も原則禁止。
- ソースコード・ブロックごとに簡潔なコメント（ラインコメント）を記述し、ブロックの終わりには改行を入れる。
  - 1行ごとにコメントを記述したり、改行を入れずに次のブロックを記述したり、コメント無しでブロックを開始しない。
- エリア終了コメントが不要なコードを書く。
  - if文やfor文などの終了コメントが必要な場合は、処理領域が長すぎる・ネストが深すぎる等の問題があるため、リファクタリングを推奨。
- 変数／定数のコメントは1行で簡潔に記述する。
  - 変数／定数の名称で内容が明確に表現されているべきであり、コメントが必要な場合は名称のリファクタリングを推奨。
- 不要なコメントアウトは除去する。
  - コメントアウトされたコードが大量に存在すると可読性が低下するため、ごく一時的なものを除き、コメントアウトは除去する。

- 以下に、例としてコメントのサンプルを示す。
  【悪い例】
  ```javascript
  this._view = this.$refs.shoukyuuShisuuSearchView;
  this._model = this._view.model;

  // イベントリスナ等の設定
  this._view.$refs.searchShoukyuuShisuu.addEventListener('click', this.searchShoukyuuShisuu);
  this._view.$refs.doSearch.addEventListener('click', this.doSearch);
  this._view.$refs.cancelSearch.addEventListener('click', this.cancelSearch);


  // サービス初期化
  this._service = new ShoukyuuShisuuService(this.serviceContext);
  // 制度コード設定
  this._model.search.seidcode = CodeModel.seidCode.tekinen.code;
  // 規約区分設定
  this._model.search.kiyakuKubun = CodeModel.kiyakuCode.kariKiyaku.code;
  ```

  【良い例】
  ```java
  // イベントリスナ等の設定
  this._view = this.$refs.shoukyuuShisuuSearchView;
  this._model = this._view.model;
  this._view.$refs.searchShoukyuuShisuu.addEventListener('click', this.searchShoukyuuShisuu);
  this._view.$refs.doSearch.addEventListener('click', this.doSearch);
  this._view.$refs.cancelSearch.addEventListener('click', this.cancelSearch);

  // サービス初期化
  this._service = new ShoukyuuShisuuService(this.serviceContext);

  // 画面クリア
  this._model.search.seidcode = CodeModel.seidCode.tekinen.code;
  this._model.search.kiyakuKubun = CodeModel.kiyakuCode.kariKiyaku.code;
  ```

  - 以下に、良い例のポイントを示す。
    - コメントの目的は、「ソースコードの大まかな処理の流れ」を読者に伝えることであり、詳細な実装の説明や技術的な手順の羅列を行うものではない。
    - 変数の初期化など、大まかな流れの理解に関係しない処理については、コメントで逐一説明する必要はなく、処理のまとまりごとにコメントを添えるのが望ましい。
    - コメントとコードは交互に1行ずつ記述しないようにする。
    - コメントはコードブロックごとにまとめて記述し、コードブロックの間には1行の空行を入れることで、処理の流れが視覚的にも追いやすくなる。

### 3.4.5 JSDocの基本指針
- JSDocは、クラスや関数、メソッドなど様々なものに対して記述可能であり、それぞれ毎のルールが存在するが、本節ではそれら全般に対する共通的な指針について記述する。

#### 3.4.5.1 JSDoc記述のポイント
- 原則として、メソッドに記述とする。
  - Vueを利用した開発では、クラスベースの構造を用いないため、クラスやクラス属性に対するJSDocコメントの記述は不要とする。
  - モデルやストア内のプロパティについては、特別な説明が必要な場合を除き、通常のコメント（//など）で対応する。
  - メソッドに対してのみ、JSDoc形式（/** ... */）でコメントを記述することを必須とする。
- `@param`、`@return`、`@throws`は必須（該当しない場合は省略可）。
- JSDocの1行目は簡潔な1文コメントを記述し、必ず「。」（句点）で終える。
  - 説明が長くなる場合やソースコード断片を記述したい場合は、HTMLタグを使用する。
  - ただし、説明が長くなるクラスやメソッド自体をなるべく作らないこと。

## 3.5 フォーマットに関する規約／指針

### 3.5.1 全般的な規約
- 1行内の文字数は132文字以内とする。
- タブ幅は半角空白4文字とする。
- タブの使用は任意とし、特に制限を設けない。
- インデントはVSCodeのフォーマット機能を適用し、原則タブによるインデントを行う。

### 3.5.2 フォーマットの整形
- 実装者はリポジトリにコミットする前に、ESLintのチェックエラー結果を解消すること。




