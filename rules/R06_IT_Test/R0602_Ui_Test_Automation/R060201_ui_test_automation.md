# 自動UIテスト 実行プロンプト（Playwright MCP 前提）

私はテスト用コードを事前に用意しません。あなた（Cursor）は **Playwright MCP** を使用して、**プロンプトで指定された画面UIテスト仕様書** からテストケースを抽出し、確実にテストを実行し、結果とエビデンスを保存してください。

## ⚠️ 重要：実行完了の徹底
- **絶対禁止**: すべてのテストケースの実行が完了する前に、Cursorの実行が終了することは許可されない
- **必須**: 各ツール呼び出し（`browser_navigate`、`browser_click`、`browser_take_screenshot` 等）の完了を必ず待機し、結果を確認してから次の操作に進むこと
- **必須**: 各テストケースの実行が完了するまで待機し、完了状態を確認してから次のテストケースに進むこと
- **必須**: すべてのテストケースの実行が完了するまで、ステップ5（結果保存と報告）に進まないこと
- **必須**: 逐次実行を徹底すること（複数のテストケースを並列実行せず、1つずつ確実に完了させること）
- **必須**: 各ステップの完了を明示的に確認し、未完了の場合は完了するまで待機すること

## 使用方法
- プロンプトで具体的なテスト仕様書ファイルを指定してください
- 例: 「`docs/tests/ui/login-screen-test-spec.md` のテストを実行してください」
- 例: 「`docs/tests/ui/login-screen-test-spec.md` と `docs/tests/ui/registration-screen-test-spec.md` のテストを実行してください」

## 重要な制約事項
- **Playwright MCP サーバーでの実行のみ**を想定しています
- **ローカル環境でのnpm操作は一切不要**です
- **設定ファイルの作成は不要**です
- **パッケージのインストールは不要**です

## 必須前提
- **Playwright MCP** が Cursor の MCP 設定で有効化されていること
- **MCP設定内容**:
  ```json
  {
    "mcpServers": {
      "playwrightMCP": {
        "command": "npx",
        "args": [
          "@playwright/mcp@latest"
        ]
      }
    }
  }
  ```
- **絶対禁止**: ローカルでの `npm init`、`npm i`、`npm install`、`yarn install`、`pnpm install` 等のパッケージ操作は **一切行わない**。  
- **絶対禁止**: `package.json` の作成や編集は **一切行わない**。
- **絶対禁止**: `node_modules` ディレクトリの作成や操作は **一切行わない**。
- **絶対禁止**: `playwright.config.ts`、`tsconfig.json` の作成や編集は **一切行わない**。
- テストの生成・実行は **Playwright MCP セッション内** で完結させること。

## 対象
- 仕様書: **プロンプトで指定された** `docs/tests/ui/*.md` ファイル
  - 各仕様書には以下が記載されている（値は含めない）  
    - テスト対象URL
    - テスト対象画面名
    - 認証要否（ログイン必要 / 不要）
    - 操作手順（画面遷移、フォーム入力、ボタンクリック等）
    - 期待結果（画面表示内容、メッセージ、遷移先等）
- 認証値（実値の所在）:  
  **`.cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\credentials.env`** を参照すること。  
  仕様書に値は書かない。

### `credentials.env` フォーマット
- 1行1設定の **KEY=VALUE** 形式（UTF-8 / BOMなし）
```
BASE_URL=https://example.com
LOGIN_EMAIL=test@example.com
LOGIN_PASSWORD=password123
ADMIN_USER=admin@example.com
ADMIN_PASSWORD=admin123
```

- 使用ルール：
  - 仕様書が相対パスの場合は `BASE_URL + パス` で解決。
  - 「ログイン必要」とあれば事前にログイン処理を実行。
  - ログイン情報は `LOGIN_EMAIL`、`LOGIN_PASSWORD` 等を使用。
  - 管理者権限が必要な場合は `ADMIN_USER`、`ADMIN_PASSWORD` を使用。

### テストデータファイルの扱い方（ファイルアップロードテスト用）

#### テストデータファイルの必要性の判定
- **プロンプトでテストデータファイルが必要な場合は明記される**
  - 例: 「`docs/tests/ui/customer-export-test-spec.md` のテストを実行してください。テストデータは `test-data/customer_export_normal.csv` を使用してください。」
  - 例: 「CSVファイルアップロード機能のテストを実行します。テストデータファイルが必要です。」
- **仕様書にファイルアップロードの指定がある場合**
  - 仕様書に「CSVファイルをアップロード」「ファイルをインポート」「CSV一括登録」などの記載がある場合、テストデータファイルを準備する
  - 仕様書にファイル名やパスが指定されている場合は、その指定に従う
  - 仕様書にファイル形式（CSV、JSON等）が指定されている場合は、その形式に合わせる

#### テストデータファイルの配置場所
- **標準配置場所**: `.cursor/rules/R06_IT_Test/R0602_Ui_Test_Automation/test-data/`
  - CSVファイル、JSONファイル、画像ファイル等のテストデータファイルを配置
  - 既存のテストデータファイル（CSVファイルアップロードテスト用）:
    - `customer_export_normal.csv`: 正常系テストデータ（標準的なCSV形式）
    - `customer_export_edge_cases.csv`: エッジケーステストデータ（異常系テスト用）
    - `customer_export_single.csv`: 単一データテスト用（最小限のデータ）
    - `customer_export_large.csv`: 大量データテスト用（パフォーマンステスト用）
- **カスタム配置場所**: プロンプトで指定された場合はそのパスを使用
  - 例: 「テストデータは `docs/test-data/custom.csv` を使用してください」

#### テストデータファイルのパス取得方法

1. **ファイルパスの取得（推奨方法）**
   - **Windows環境（PowerShell）**: `run_terminal_cmd` を使用してPowerShellコマンドで絶対パスを取得
   - プロジェクトルート（`C:\facePlatform`）からの相対パスを絶対パスに変換
   - **推奨パス取得方法**:
     ```powershell
     # PowerShellコマンドで絶対パスを取得
     $filePath = (Resolve-Path ".cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv").Path
     Write-Output $filePath
     # 結果例: C:\facePlatform\.cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv
     ```
   - **代替方法**: `browser_evaluate` ツールを使用してNode.jsの `path` モジュールでファイルパスを取得することも可能だが、PowerShellコマンドの方が簡単で確実
   - 代替パス取得例（参考）:
     ```javascript
     // browser_evaluate で実行（ブラウザコンテキストでは実行できないため、実際には使用しない）
     // 注意: browser_evaluate はブラウザコンテキストで実行されるため、Node.jsのrequireは使用できない
     // そのため、この方法は使用しない
     ```

2. **ファイル存在確認**
   - ファイルをアップロードする前に、ファイルが存在することを確認する
   - **推奨方法**: PowerShellコマンドで存在確認:
     ```powershell
     # PowerShellコマンドでファイル存在確認
     $filePath = ".cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv"
     if (Test-Path $filePath) {
       Write-Output "ファイルが存在します: $filePath"
     } else {
       Write-Output "エラー: ファイルが見つかりません: $filePath"
       exit 1
     }
     ```
   - **代替方法**: `run_terminal_cmd` でファイル存在確認後、絶対パスを取得することも可能

#### ファイルアップロードテストの実行方法

1. **ファイルアップロード要素の特定**
   - `browser_snapshot` でページ構造を取得し、ファイルアップロード要素（`input[type="file"]`）またはファイル選択ボタンを特定
   - 要素の `ref` を取得して、`browser_click` と `browser_file_upload` で使用
   - **重要**: ファイル選択ボタンは「ファイルを選択 prepended action」や「ファイルを選択」などのテキストで識別される場合がある

2. **ファイルアップロードの実行（標準手順）**
   - **重要**: `browser_file_upload` を使用するには、ファイル選択ダイアログ（モーダル）が開いている状態である必要がある
   - **必須手順**:
     1. **ファイル選択ボタンをクリック**
        - `browser_snapshot` で取得したファイル選択ボタンの `ref` を使用
        - `browser_click(element="ファイルを選択 prepended action", ref="e441")` などでクリック
        - または「ファイルを選択」などのテキストを含むボタンをクリック
     2. **ファイル選択ダイアログの待機**
        - `browser_wait_for` で1-2秒待機（ダイアログが開くまで）
        - `browser_snapshot` を再度実行すると、モーダル状態が「[File chooser]: can be handled by the "browser_file_upload" tool」と表示される
     3. **ファイルパスの絶対パス変換**
        - **重要**: `browser_file_upload` は絶対パスを要求するため、必ず絶対パスに変換する
        - Windows環境（PowerShell）の場合:
          ```powershell
          # PowerShellコマンドで絶対パスを取得
          $filePath = (Resolve-Path ".cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv").Path
          # 結果例: C:\facePlatform\.cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv
          ```
     4. **ファイルをアップロード**
        - `browser_file_upload` ツールを使用してファイルをアップロード
        - アップロード例:
          ```json
          {
            "paths": ["C:\\facePlatform\\.cursor\\rules\\R06_IT_Test\\R0602_Ui_Test_Automation\\test-data\\customer_export_normal.csv"]
          }
          ```
   - **実行フロー例**:
     ```
     1. browser_snapshot() → ファイル選択ボタンのrefを取得（例: ref="e441"）
     2. browser_click(element="ファイルを選択 prepended action", ref="e441")
     3. browser_wait_for(time=2) → ファイル選択ダイアログが開くまで待機
     4. run_terminal_cmd → PowerShellで絶対パスを取得
     5. browser_file_upload(paths=["絶対パス"]) → ファイルをアップロード
     6. browser_wait_for(time=2) → アップロード処理の完了を待機
     7. browser_snapshot() → アップロード後の画面状態を確認
     ```
   - **注意**: 
     - ファイル選択ダイアログが開いていない状態で `browser_file_upload` を実行すると、「The tool "browser_file_upload" can only be used when there is related modal state present.」というエラーが発生する
     - ファイル選択ボタンのクリックがタイムアウトする場合があるが、その場合は `browser_evaluate` で `input[type="file"]` 要素を見つけて、直接ファイルパスを設定する方法はブラウザのセキュリティ制限により不可能
     - ファイル選択ボタンをクリックした後、必ず `browser_wait_for` で待機してから `browser_file_upload` を実行すること

3. **アップロード後の検証**
   - アップロード完了後の画面状態を `browser_snapshot` で取得
   - 以下の項目を検証：
     - **成功時の検証**:
       - 成功メッセージの表示（「アップロード成功」「CSVファイルをアップロードしました」等）
       - アップロードされたファイル名の表示
       - データの反映（一覧画面にデータが追加されている等）
       - エラーメッセージが表示されていないこと
     - **失敗時の検証**:
       - エラーメッセージの表示（「ファイル形式が正しくありません」「ファイルサイズが大きすぎます」等）
       - 適切なエラーメッセージが表示されていること
       - 画面遷移が発生していないこと（エラー画面に遷移していないこと）

4. **アップロード処理の待機**
   - ファイルアップロード後、アップロード処理が完了するまで待機する
   - `browser_wait_for` で成功メッセージやエラーメッセージの表示を待つ
   - 待機例:
     ```javascript
     // 成功メッセージの表示を待つ
     await browser_wait_for({ text: 'アップロード成功' });
     // またはエラーメッセージの表示を待つ
     await browser_wait_for({ text: 'ファイル形式が正しくありません' });
     ```

#### テストデータファイル使用時の注意事項

1. **パスの解決**
   - 相対パスはプロジェクトルート（`C:\facePlatform`）からの相対パスとして扱う
   - 絶対パスが必要な場合は `path.resolve()` または `path.join()` を使用
   - Windows環境を考慮してパス区切り文字は `path.join()` を使用
   - **重要**: `browser_file_upload` は絶対パスを要求するため、必ず絶対パスに変換する

2. **文字エンコーディング**
   - CSVファイルはUTF-8（BOMなし）で保存されていることを前提とする
   - 日本語が含まれる場合は文字化けに注意（アップロード後の画面で確認）

3. **エラーハンドリング**
   - ファイルが存在しない場合: エラーメッセージを出力し、テストをスキップまたは失敗とする
   - ファイルパスの解決に失敗した場合: エラーメッセージを出力し、詳細を記録する
   - ファイルアップロードに失敗した場合: エラーメッセージを出力し、スクリーンショットを保存する
   - エラー内容は実行ログに記録する

4. **テストデータファイルの管理**
   - テストデータファイルはテスト実行前に存在確認する
   - テストデータファイルの内容は実行ログに記録しない（機密情報が含まれる可能性があるため）
   - テストデータファイルのパスとファイル名のみをログに記録する
   - ファイルサイズが大きい場合は、アップロード処理のタイムアウトに注意する

5. **テストデータファイルの準備**
   - プロンプトでテストデータファイルが指定されていない場合でも、仕様書にファイルアップロードが必要と記載されている場合は自動的に準備する
   - 既存のテストデータファイルを確認し、適切なものを選択する
   - 既存のテストデータファイルが適切でない場合は、必要に応じて新規作成する
   - テスト仕様に応じて、正常系・異常系・エッジケース用のファイルを選択する
   - **新規ファイル作成時の注意事項**:
     - **文字エンコーディング**: CSVファイルは必ずUTF-8（BOMなし）で保存する
     - **`edit_file`ツールを使用したファイル作成**:
       - `edit_file`ツールを使用して直接CSVファイルを作成する
       - `edit_file`ツールは自動的にUTF-8（BOMなし）で保存される
       - ファイル作成例:
         ```markdown
         # edit_fileツールでCSVファイルを作成
         edit_file(
           target_file=".cursor/rules/R06_IT_Test/R0602_Ui_Test_Automation/test-data/test_data.csv",
           instructions="CSVファイルを作成します。顧客情報のテストデータです。",
           code_edit="customerId,userFamilyName,userFirstName,userFamilyNameFurigana,userFirstNameFurigana,groupPath,enabledDate,disabledDate
         CUST001,田中,太郎,タナカ,タロウ,人事部_人事課,2011-11-11,2030-11-11"
         )
         ```
       - **メリット**: 
         - ツールの使用でワークフローがシンプル
         - エンコーディングを気にせず作成可能
         - コードの一部として管理しやすい
     - **ファイルパスの取得**: ファイル作成後、絶対パスを取得する:
       ```powershell
       $filePath = (Resolve-Path ".cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\test_data.csv").Path
       Write-Output $filePath
       ```

## 実施フロー（必ず MCP 経由）

### ステップ1: テストケース抽出とファイル化
1. **仕様書の読み込み**  
   - **プロンプトで指定された** `docs/tests/ui/*.md` ファイルを読み込む
   - 各ファイルから以下を抽出：
     - テスト対象URL
     - 認証要否
     - 「テスト仕様書」「バリエーション」テーブルの**すべてのテストケース**
     - 操作手順（画面要素の特定方法、入力値、クリック対象等）
     - 期待結果（表示テキスト、エラーメッセージ、遷移先URL等）

2. **テストケースファイルの生成**  
   - 仕様書から抽出したテストケースを `docs/tests/ui_results/<テスト仕様書名>/test-cases.json` に保存
   - フォーマット（以下例）:
     ```json
     {
       "specFile": "docs/tests/ui/login-screen-test-spec.md",
       "testCases": [
         {
           "caseId": "TC001",
           "description": "正常ログイン",
           "steps": ["ログイン画面に遷移", "メールアドレス入力", "パスワード入力", "ログインボタンをクリック"],
           "expectedResult": "ダッシュボード画面に遷移"
         }
       ]
     }
     ```

### ステップ1.5: テストケース合致確認（実行前検証）
**🔍 重要: テスト実行前に仕様書との整合性を必ず確認すること**

1. **仕様書のテストケースリスト作成（メモリ上）**
   - 仕様書から「テスト仕様書」テーブルと「バリエーション」テーブルのすべてのテストケースIDと説明を抽出
   - 仕様書由来のリストはメモリ上で保持し、ファイルには保存しない

2. **抽出したテストケースとの照合**
   - ステップ1で生成した `test-cases.json` と、メモリ上の仕様書由来リストを比較
   - 目的: テスト仕様書と抽出結果の整合性、および要件と重複/齟齬がないか（かぶりの有無）を検証
   - 以下を確認：
     - ✅ **網羅性確認**: 仕様書のすべてのテストケースが抽出されているか
     - ✅ **重複確認**: 同じテストケースが重複して抽出されていないか
     - ✅ **整合性確認**: 各テストケースの内容（操作手順、期待結果）が仕様書と一致しているか
     - ✅ **欠落確認**: 抽出されなかったテストケースがないか

3. **合致確認レポートの生成**
   - 照合結果を `docs/tests/ui_results/<テスト仕様書名>/test-case-verification-report.md` に保存
   - レポート内容:
     ```markdown
     # テストケース合致確認レポート（実行前）
     
     ## 検証概要
     - 仕様書: `docs/tests/ui/login-screen-test-spec.md`
     - 検証日時: YYYY-MM-DD HH:MM:SS
     - 仕様書記載テストケース数: XX
     - 抽出テストケース数: XX
     
     ## 合致確認結果
     
     ### ✅ 抽出成功（仕様書と一致）
     | テストケースID | 説明 | 仕様書の記載 | 抽出結果 |
     |:---|:---|:---|:---|
     | TC001 | 正常ログイン | あり | ✅ 抽出済み |
     
     ### ⚠️ 抽出漏れ（仕様書にあるが抽出されていない）
     | テストケースID | 説明 | 仕様書の記載 | 問題 |
     |:---|:---|:---|:---|
     | TC003 | パスワード忘れ | あり | ❌ 抽出されていない |
     
     ### ❌ 重複（同じテストケースが複数回抽出）
     | テストケースID | 説明 | 重複回数 |
     |:---|:---|:---|
     | TC001 | 正常ログイン | 2回 |
     
     ### ⚠️ 不一致（内容が仕様書と異なる）
     | テストケースID | 説明 | 項目 | 仕様書 | 抽出結果 |
     |:---|:---|:---|:---|:---|
     | TC002 | 無効なメール形式 | 期待結果 | エラーメッセージ表示 | 画面遷移なし |
     
     ## 検証結果サマリー
     - ✅ すべてのテストケースが正しく抽出されました（または問題点の指摘）
     - ⚠️ 以下の問題を修正してから実行してください
     ```

4. **問題がある場合の対処**
   - **抽出漏れがある場合**: エラーを報告し、漏れているテストケースを追加してから次のステップに進む
   - **重複がある場合**: エラーを報告し、重複を削除してから次のステップに進む
   - **不一致がある場合**: 警告を報告し、ユーザーに確認を求める（または自動修正）
   - **すべて一致する場合**: 次のステップに進む

5. **合致確認の必須実施**
   - **🚫 絶対禁止**: 合致確認を省略してテストを実行することは許可されない
   - **必須**: すべてのテストケースが正しく抽出されていることを確認してから実行する
   - **必須**: 合致確認レポートを保存し、最終的なサマリーに含める

### ステップ2: Playwright MCP実行計画の生成
3. **実行計画の作成**  
  - `docs/tests/ui_results/<テスト仕様書名>/test-cases.json` を読み込み、Playwright MCP の操作シーケンスを計画
   - 使用する MCP ツール:
     - `browser_navigate`: URL遷移
     - `browser_snapshot`: 画面状態の取得とアサーション用
     - `browser_type`: テキスト入力
     - `browser_click`: ボタン/リンククリック
     - `browser_fill_form`: フォーム一括入力
     - `browser_take_screenshot`: スクリーンショット保存
     - `browser_wait_for`: 要素の表示待機
     - `browser_select_option`: ドロップダウン選択
     - `browser_evaluate`: JavaScriptの実行
   - **重要**: 各テストケースを順次実行し、結果を記録
   - **🚫 絶対禁止**: テストスクリプトファイル（.spec.ts等）は作成しない。すべてPlaywright MCP ツールの直接呼び出しで実行

### ステップ3: 認証・共通設定の適用
4. **認証情報の適用**  
   - `credentials.env` を読み込む
   - 仕様書がフルURLでない場合、`BASE_URL` を前置
   - 「ログイン必要」の場合、テスト実行前にログイン処理を実行
   - ログイン状態をセッション/Cookie/LocalStorageで保持

### ステップ4: テスト実行
5. **テストデータファイルの準備（ファイルアップロードテストの場合）**
   - **プロンプトでテストデータファイルが指定されている場合**、または**仕様書にファイルアップロードが必要と記載されている場合**:
     1. テストデータファイルの存在確認
        - 標準配置場所（`.cursor/rules/R06_IT_Test/R0602_Ui_Test_Automation/test-data/`）を確認
        - プロンプトで指定されたパスを確認
        - **推奨方法**: PowerShellコマンドでファイル存在確認:
          ```powershell
          $filePath = ".cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv"
          if (Test-Path $filePath) {
            Write-Output "ファイルが存在します: $filePath"
          } else {
            Write-Output "エラー: ファイルが見つかりません: $filePath"
            exit 1
          }
          ```
        - **注意**: `browser_evaluate` で `fs.existsSync()` を使用することも可能だが、PowerShellコマンドの方が簡単で確実
     2. テストデータファイルのパス解決
        - 相対パスを絶対パスに変換する
        - **Windows環境（推奨）**: PowerShellコマンドで絶対パスを取得:
          ```powershell
          $filePath = (Resolve-Path ".cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv").Path
          Write-Output $filePath
          ```
        - **注意**: `browser_evaluate` でNode.jsの `path` モジュールを使用することも可能だが、PowerShellコマンドの方が簡単で確実
        - **重要**: `browser_file_upload` は絶対パスを要求するため、必ず絶対パスに変換
     3. エラーハンドリング
        - ファイルが存在しない場合: エラーメッセージを出力し、テストをスキップまたは失敗とする
        - ファイルパスの解決に失敗した場合: エラーメッセージを出力し、詳細を記録する

6. **実行（MCP 経由）**  
   - **Playwright MCPツールを直接呼び出してUIテストを実行する**
   - **⚠️ 最重要**: このセクション（ステップ4）を開始したら、すべてのテストケースの実行が完了するまで、Cursorの実行を終了させてはならない
   - **⚠️ 最重要**: `test-cases.json` に記載されたすべてのテストケースを順次実行し、すべての実行が完了するまで次のステップ（ステップ5）に進まないこと
   - **必須**: 各テストケースの実行が完了するまで確実に待機し、完了状態を明示的に確認してから次のテストケースに進むこと
   - **必須**: エラーが発生した場合でも、可能な限り残りのテストケースを実行すること（早期終了を避ける）
   - **必須**: 各ツール呼び出しの戻り値を確認し、エラーがないことを確認してから次の操作に進むこと
   - **必須**: 各テストケース実行後、そのテストケースの完了を記録し、進捗を確認すること
   - **実行前確認**: 実行対象のテストケース一覧を確認し、すべてのテストケースIDを記録する
   - **実行ループ**: すべてのテストケースを順次実行するループを開始し、最後のテストケースが完了するまでループを継続すること
   - 各テストケースごとに以下を実行：
     1. ブラウザセッションの開始（初回のみ）
     2. 必要に応じてログイン処理
     3. テスト対象画面への遷移
     4. **ファイルアップロードテストの場合**（標準手順）:
        - **手順1**: `browser_snapshot` でファイル選択ボタンを特定
          - 「ファイルを選択 prepended action」「ファイルを選択」などのテキストを含むボタンを探す
          - ボタンの `ref` を取得（例: `ref="e441"`）
        - **手順2**: ファイル選択ボタンをクリック
          - `browser_click(element="ファイルを選択 prepended action", ref="e441")` などでクリック
          - クリック後、ファイル選択ダイアログが開くまで待機
        - **手順3**: ファイル選択ダイアログの待機
          - `browser_wait_for(time=2)` で1-2秒待機
          - `browser_snapshot` を再度実行すると、モーダル状態が「[File chooser]: can be handled by the "browser_file_upload" tool」と表示されることを確認
        - **手順4**: ファイルパスの絶対パス変換
          - PowerShellコマンドで絶対パスを取得:
            ```powershell
            $filePath = (Resolve-Path ".cursor\rules\R06_IT_Test\R0602_Ui_Test_Automation\test-data\customer_export_normal.csv").Path
            Write-Output $filePath
            ```
        - **手順5**: ファイルをアップロード
          - `browser_file_upload(paths=["絶対パス"])` でファイルをアップロード
          - アップロード後、`browser_wait_for(time=2)` でアップロード処理の完了を待機
        - **手順6**: アップロード後の画面状態確認
          - `browser_snapshot` でアップロード後の画面状態を取得
          - ファイル名が表示されているか、ボタンの状態が更新されているかを確認
          - `browser_wait_for` で成功メッセージまたはエラーメッセージの表示を待つ
     5. 操作手順の実行（フォーム入力、ボタンクリック等）
        - ファイルアップロード以外の操作を実行
        - **重要**: ボタンクリックから処理完了までの時間測定を実施する（ストップウォッチ方式）
          - **処理開始時刻の記録**: ボタンクリック実行直前（`browser_click` 実行前）に、`browser_evaluate` で `performance.now()` を使用して開始時刻を記録（高精度タイムスタンプ）
          - **ストップウォッチの開始**: `browser_evaluate` でブラウザ内にストップウォッチオブジェクトを作成し、`performance.now()` で開始時刻を記録
            ```javascript
            // ストップウォッチ初期化例
            await browser_evaluate(() => {
              window.testStopwatch = {
                start: performance.now(),
                startTimestamp: new Date().toISOString()
              };
            });
            ```
          - **ボタンクリック実行**: `browser_click` で処理開始ボタンをクリック
          - **処理完了の待機**: `browser_evaluate` と `browser_wait_for` を組み合わせて、処理完了条件を監視しながら経過時間を計測
            - 成功メッセージの表示を待機（`browser_wait_for` で成功メッセージのテキストを待機）
            - 画面遷移の完了を待機（URL変更の確認）
            - エラーメッセージの表示を待機（異常系テストの場合、`browser_wait_for` でエラーメッセージのテキストを待機）
            - ローディング表示の消滅を待機（ローディングインジケーターの非表示）
          - **処理完了条件の確認**: `browser_evaluate` で `waitForFunction()` 相当の処理を実装
            ```javascript
            // 処理完了条件を監視しながら経過時間を計測
            const processResult = await browser_evaluate(() => {
              return new Promise((resolve) => {
                const checkInterval = setInterval(() => {
                  const elapsed = performance.now() - window.testStopwatch.start;
                  // 処理完了条件をチェック
                  const isComplete = /* 完了条件の判定 */;
                  if (isComplete) {
                    clearInterval(checkInterval);
                    resolve({
                      elapsed: elapsed,
                      endTime: performance.now(),
                      endTimestamp: new Date().toISOString()
                    });
                  }
                }, 100); // 100msごとにチェック
              });
            });
            ```
          - **処理時間の取得**: 処理完了後に `browser_evaluate` で終了時刻を取得し、処理時間を計算（ミリ秒単位）
            ```javascript
            const finalTime = await browser_evaluate(() => {
              const end = performance.now();
              return {
                start: window.testStopwatch.start,
                end: end,
                elapsed: end - window.testStopwatch.start,
                startTimestamp: window.testStopwatch.startTimestamp,
                endTimestamp: new Date().toISOString()
              };
            });
            ```
          - **記録**: 処理時間をテストケースの実行結果に含める
            - 処理時間（ミリ秒、秒単位も併記）
            - 開始時刻（YYYY-MM-DD HH:MM:SS.mmm）
            - 終了時刻（YYYY-MM-DD HH:MM:SS.mmm）
     6. 画面状態の取得（`browser_snapshot`）
     7. アサーションの実行（期待値との比較）
        - **ファイルアップロード成功時の検証**:
          - 成功メッセージの表示確認
          - アップロードされたファイル名の表示確認
          - データの反映確認（一覧画面にデータが追加されている等）
        - **ファイルアップロード失敗時の検証**:
          - エラーメッセージの表示確認
          - 適切なエラーメッセージが表示されていることの確認
     8. スクリーンショットの保存
        - アップロード前の画面状態
        - アップロード後の画面状態（成功/失敗）
        - 取得時は `browser_take_screenshot` の `filename` にファイル名のみを指定する（`.playwright-mcp` 直下に保存される）
          - 例: `browser_take_screenshot(filename="<テストケースID>-<ステップ名>.png")`
     9. 結果の記録
        - 使用したテストデータファイルのパスとファイル名を記録
        - アップロード結果（成功/失敗）を記録
        - 表示されたメッセージ（成功メッセージまたはエラーメッセージ）を記録
        - **処理時間の記録**: ボタンクリックから処理完了までの時間（ミリ秒）を記録
          - 処理対象ボタン名（例: 「ログインボタン」「アップロードボタン」等）
          - 開始時刻（YYYY-MM-DD HH:MM:SS.mmm）
          - 終了時刻（YYYY-MM-DD HH:MM:SS.mmm）
          - 処理時間（ミリ秒、秒単位も併記）
        - **テストケース完了の記録**: このテストケースの実行が完了したことを記録し、次のテストケースに進む前に完了状態を確認する
   - **正常系テストの優先実行**:
     - 正常系テスト（TC001等）が失敗した場合、画面の実装に問題がある可能性がある
     - 正常系テストが成功するまで、異常系テストの結果は参考程度として扱う
   - **⚠️ 実行完了確認（必須）**: すべてのテストケースの実行が完了したことを確認してから次のステップ（ステップ5）に進むこと
     - **必須手順1**: 実行対象テストケース数をカウントし、記録する
     - **必須手順2**: 各テストケースの実行完了を記録しながら、実行完了数をカウントする
     - **必須手順3**: すべてのテストケースの実行が完了したら、実行対象数と実行完了数が一致することを確認する
     - **必須手順4**: 一致しない場合は、未実行のテストケースIDを特定し、それらを実行してから次のステップに進む
     - **必須手順5**: すべてのテストケースが完了したことを確認したら、その旨を明示的に報告してからステップ5に進む
     - **🚫 絶対禁止**: 実行完了確認を省略してステップ5に進むこと
     - **🚫 絶対禁止**: 未実行のテストケースがあるままステップ5に進むこと
   - **🚫 絶対禁止**: ローカルの `npm init`、`npm i`、`npm install`、`yarn install`、`pnpm install` 等のパッケージ操作は一切行わない
   - **🚫 絶対禁止**: ローカルでの `playwright install` や `npx playwright install` 等のコマンドは一切実行しない
   - **🚫 絶対禁止**: Windows PowerShellで`&&`を使用したコマンド連結は行わない
   - **🚫 絶対禁止**: すべてのテストケースの実行が完了する前に、ステップ5（結果保存と報告）に進むこと

### ステップ5: 結果保存と報告
**⚠️ 前提条件（必須確認）**: ステップ4（テスト実行）ですべてのテストケースの実行が完了していることを確認してから本ステップに進むこと
- **必須**: ステップ5を開始する前に、実行対象テストケース数と実行完了数が一致することを再度確認する
- **必須**: 未完了のテストケースがある場合は、ステップ5に進まず、先に未完了のテストケースを実行する
- **🚫 絶対禁止**: 未完了のテストケースがあるままステップ5を開始すること

6. **保存と報告**  
   - 結果とエビデンスを `docs/tests/ui_results/<テスト仕様書名>/` に保存（保存規約参照）
   - スクリーンショット移送（テスト終了後・Nodeのみ）:
     - 手順A: 雛形 `move-screenshots-template.js` の `%%FROM_DIR%%` を `.playwright-mcp`、`%%TO_DIR%%` を `docs/tests/ui_results/<テスト仕様書名>/screenshots` に置換した一時スクリプト（例: `move-screenshots-run.js`）を生成
     - 手順B: Node.js で実行（例: `node .cursor/rules/R06_IT_Test/R0602_Ui_Test_Automation/move-screenshots-run.js`）
     - 手順C: 実行後に一時スクリプトを削除
   - **テストケース実行結果の合致確認（実行後検証）**:
     - 実際に実行したテストケースと仕様書のテストケースを再度照合
     - 実行されなかったテストケースがないか確認
     - 実行結果を `test-case-execution-verification.md` に保存
     - フォーマット:
       ```markdown
       # テストケース実行結果合致確認レポート
       
       ## 検証概要
       - 仕様書: `docs/tests/ui/login-screen-test-spec.md`
       - 実行日時: YYYY-MM-DD HH:MM:SS
       - 仕様書記載テストケース数: XX
       - 実行されたテストケース数: XX
       
       ## 実行カバレッジ
       
       ### ✅ 実行完了（仕様書のテストケースを実行）
       | テストケースID | 説明 | 仕様書の記載 | 実行結果 | テスト結果 |
       |:---|:---|:---|:---|:---|
       | TC001 | 正常ログイン | あり | ✅ 実行済み | PASS |
       | TC002 | 無効なメール形式 | あり | ✅ 実行済み | FAIL |
       
       ### ❌ 未実行（仕様書にあるが実行されていない）
       | テストケースID | 説明 | 仕様書の記載 | 理由 |
       |:---|:---|:---|:---|
       | TC003 | パスワード忘れ | あり | 実行されていない |
       
       ### ⚠️ 仕様書外実行（仕様書にないテストケースを実行）
       | テストケースID | 説明 | 実行結果 | 備考 |
       |:---|:---|:---|:---|
       | TC999 | 追加テスト | PASS | 仕様書に記載なし |
       
       ## カバレッジサマリー
       - カバレッジ率: XX% (実行済み XX / 総数 XX)
       - ✅ すべての仕様書記載テストケースを実行しました
       - ⚠️ 以下のテストケースが未実行です: TC003
       ```
- **見やすいサマリーファイルの生成**:
    - `test-results-summary.md`: 全体のテスト結果をMarkdown形式で見やすくまとめ（メインファイル）
    - すべてのテスト結果情報をこの1つのファイルに集約
    - **必須**: **すべてのテストケース**（成功・失敗問わず）の詳細を必ず記載する
    - **必須**: 各テストケースに期待結果と実際結果を並べて記載
    - **必須**: 各テストケースの実行ログをそのままコピペして記載
    - **必須**: 全体の実行ログサマリーを最後に記載
    - **必須**: テストケース合致確認レポート（実行前・実行後）を含める
    - **重要**: テストケースの記載漏れは絶対に避けること
  - **スクリーンショットの保存**:
   - 各テストケースの実行時にスクリーンショットを保存
   - 一時保存先: `.playwright-mcp` 直下（`filename` にファイル名のみを指定）
   - ファイル名: `<テストケースID>-<ステップ名>.png`
   - サマリーファイルにスクリーンショットへのリンクを記載（移送後の保存先を記載）
  - `browser_take_screenshot` の引数名は `filename`です。ファイル名のみを指定します（`.playwright-mcp` 直下に保存される）
    - 例: `browser_take_screenshot(filename="TC001-step1-before.png")`
    - 例: `browser_take_screenshot(filename="<テストケースID>-<ステップ名>.png")`
   - **Playwright MCPログの取得**:
     - Playwright MCPの実行時に出力される実際のログを取得する（個別ファイルには保存せず、サマリー等へ記載）
     - 生成したログではなく、Playwrightが実際に出力するログを使用する
     - ブラウザコンソール出力、実行ログ、エラーメッセージ等を `test-results-summary.md` へ抜粋・記載する
   - 実行完了後、失敗ケースの要約・スクリーンショットパス・エビデンスパスを報告する

## 実行ポリシー（既定値）
- タイムアウト: 30,000ms（画面操作用）
- 要素待機: 10,000ms
- ページ遷移待機: 30,000ms
- リトライ: ネットワークエラー/タイムアウトを最大 2 回、1000ms 間隔  
- ブラウザ: Chromium（デフォルト）
- ウィンドウサイズ: 1920x1080
- 環境変数置換: 仕様書内 `${NAME}` は `credentials.env`（→必要に応じて Cursor 環境変数）で上書き
- **実行環境対応**:
  - 実行環境はNode.js実行を前提（PowerShell等のOS依存ツールは不要）
  - コマンド実行は個別に行う（連結実行は不要）
  - Playwright MCP ツールを直接呼び出すため、追加のテストスクリプトは不要

## 保存規約（必須）
- ルート: `docs/tests/ui_results/<テスト仕様書名>/`（テスト仕様書名でフォルダ分割）
  - `<テスト仕様書名>`: テスト仕様書ファイル名から `.md` を除いた名前（例：`login-screen-test-spec`）
- 生成物:
  - `test-cases.json` …… 仕様書抽出テストケース
  - `screenshots/` …… スクリーンショット一式
  - `test-results-summary.md` …… テスト結果の見やすいサマリー（メインファイル、合致確認レポート含む）
  - `test-case-verification-report.md` …… テストケース合致確認レポート（実行前）
  - `test-case-execution-verification.md` …… テストケース実行結果合致確認レポート（実行後）
- 既存成果物は上書きする（最新の実行結果で更新）
- **注意**: 個別のテストスクリプトファイル（.spec.ts等）は生成しない

### 保存パス例
- 仕様書: `docs/tests/ui/login-screen-test-spec.md`
- 保存先: `docs/tests/ui_results/login-screen-test-spec/`
- 仕様書: `docs/tests/ui/face-recognition-screen-test-spec.md` 
- 保存先: `docs/tests/ui_results/face-recognition-screen-test-spec/`

### 複数仕様書を同時実行する場合
- 各仕様書ごとに個別のフォルダを作成
- 例：
  ```
  docs/tests/ui_results/
  ├── login-screen-test-spec/
  │   ├── screenshots/
  │   ├── test-results-summary.md
  │   └── ...
  └── menu-selection-screen-test-spec/
      ├── screenshots/
      ├── test-results-summary.md
      └── ...
  ```

## テストケース抽出ルール
- **テスト仕様書テーブル**: 概要と件数
- **バリエーションテーブル**: 個別の操作手順と期待結果
  - 各行を個別のテストケースとして扱う
  - 操作手順とアサーションを確実に含める
- **画面要素の特定方法**:
  - セレクター優先順位: `data-testid` > `id` > `name` > `class` > XPath
  - 人間が読める要素記述（例: 「メールアドレス入力欄」）からPlaywright MCPの `ref` を特定
  - `browser_snapshot` でページ構造を取得し、適切なセレクターを判断
- **入力値制限テストケースの正確性確保**:
  - 文字数制限をテストする場合、テストデータの文字数を正確に計算して生成する
  - 例：「41文字の場合」と記載されている場合は、必ず41文字の文字列を生成する
  - 例：「51文字の場合」と記載されている場合は、必ず51文字の文字列を生成する
  - 文字数計算方法：
    - 英数字の場合：`'a'.repeat(文字数)` を使用
    - 日本語の場合：`'あ'.repeat(文字数)` を使用
    - 混合の場合：指定された文字数になるよう正確に計算
  - **検証必須**: 生成したテストデータの文字数を必ず確認し、期待値と一致することを検証する
- 期待値の例：
  - 「エラーメッセージ：メールアドレスの形式が正しくありません」→ 画面内テキスト存在確認
  - 「ダッシュボード画面に遷移」→ URL確認 + ページタイトル確認
  - 「ボタンが非活性」→ 要素の disabled 属性確認
- **画面状態検証の強化**:
  - エラーメッセージだけでなく、画面全体の状態を検証
  - 正常系テスト: 期待される画面遷移、要素の表示、データの表示
  - 異常系テスト: 適切なエラーメッセージ、画面遷移なし、フォーム入力値の保持
  - 状態確認: ボタンの有効/無効、ローディング表示、モーダル表示等
- **全テストケース詳細記載の必須実装**:
  - テスト実行後、**すべてのテストケース**（成功・失敗問わず）の詳細を必ず記載する
  - テストケースの記載漏れは絶対に避ける
  - 各テストケースには以下を必ず含める：
    - 操作手順詳細（URL、入力値、クリック対象等）
    - 期待結果（画面表示内容、メッセージ、遷移先URL等）
    - 実際結果（実際の画面状態、メッセージ、URL等）
    - 検証結果（各項目の成功/失敗）
    - **処理時間**（ボタンクリックから処理完了までの時間、ミリ秒・秒単位）
    - スクリーンショット（各ステップの画面キャプチャ）
    - 実行ログ（タイムスタンプ付き）
- **Playwright MCP実行ログの必須実装**:
  - Playwright MCPツールが実際に出力するログをそのままコピーしてエビデンスとする
  - 生成したログではなく、Playwrightの実際の実行ログを使用する
  - **重要**: Playwright MCPの実行時に出力される以下のログを必ず取得・記録する：
    - ブラウザコンソール出力（console.log、console.error等）
    - 実行ログ（ページ遷移、要素操作、待機等）
    - 各テストケースの実行結果（成功/失敗）
    - エラーメッセージ（要素が見つからない、タイムアウト等）
    - 実行時間とサマリー
  - **実装方法**: Playwright MCPツールの戻り値から実際のログ出力を取得し、そのままコピーする

## 出力（報告メッセージに含めること）
- **テストケース合致確認結果**:
  - 仕様書記載テストケース数 / 抽出テストケース数
  - 抽出漏れ・重複・不一致の有無
  - カバレッジ率（実行済み / 総数）
  - 未実行テストケースの有無
- **テストデータファイル使用状況**（ファイルアップロードテストの場合）:
  - 使用したテストデータファイルのパスとファイル名
  - ファイル存在確認の結果
  - ファイルパスの解決結果（絶対パスへの変換）
  - ファイルアップロードの実行結果（成功/失敗）
  - アップロード後の検証結果（成功メッセージ/エラーメッセージの表示確認）
- **テスト実行結果**:
  - 成功数 / 失敗数 / 総テスト数
  - 失敗ケース名
  - 各失敗の詳細（例：要素が見つからない、期待テキストと実際テキストの差分）
  - スクリーンショット抜粋（失敗時の画面状態）
  - ブラウザコンソールエラー抜粋
  - **テストデータファイル関連のエラー**（ファイルが存在しない、パス解決に失敗した、アップロードに失敗した等）
  - **処理時間の記録**:
    - 各テストケースのボタンクリックから処理完了までの時間（ミリ秒・秒単位）
    - 処理対象ボタン名と処理時間の一覧
    - 平均処理時間（複数テストケースがある場合）
- **エビデンスパス**:
  - `docs/tests/ui_results/<テスト仕様書名>/` のパス
  - `test-results-summary.md` のパス
  - `test-case-verification-report.md` のパス
  - `test-case-execution-verification.md` のパス

## サマリーファイル形式

### test-results-summary.md の構成
```markdown
# UIテスト結果サマリー

## 実行概要
- 実行日時: YYYY-MM-DD HH:MM:SS
- 総テスト数: XX
- 成功: XX
- 失敗: XX
- 実行時間: XXXms
- ブラウザ: Chromium
- **テストデータファイル**（ファイルアップロードテストの場合）:
  - 使用ファイル: `customer_export_normal.csv`
  - ファイルパス: `.cursor/rules/R06_IT_Test/R0602_Ui_Test_Automation/test-data/customer_export_normal.csv`
  - ファイル存在確認: ✅ 成功
  - パス解決: ✅ 成功（絶対パスに変換完了）
  - アップロード結果: ✅ 成功 / ❌ 失敗
  - アップロード後のメッセージ: 「アップロード成功」/ エラーメッセージ

## テストケース合致確認（実行前検証）

### 仕様書との整合性確認
- 仕様書: `docs/tests/ui/login-screen-test-spec.md`
- 仕様書記載テストケース数: XX
- 抽出テストケース数: XX
- 抽出精度: 100%

### 抽出結果サマリー
| 項目 | 件数 | ステータス |
|:---|:---|:---|
| ✅ 抽出成功（仕様書と一致） | XX | 正常 |
| ❌ 抽出漏れ | 0 | 問題なし |
| ❌ 重複 | 0 | 問題なし |
| ⚠️ 不一致 | 0 | 問題なし |

詳細は [test-case-verification-report.md](test-case-verification-report.md) を参照

## テストケース実行カバレッジ（実行後検証）

### 実行カバレッジサマリー
- カバレッジ率: 100% (実行済み XX / 総数 XX)
- ✅ すべての仕様書記載テストケースを実行しました

### 実行結果内訳
| 項目 | 件数 | ステータス |
|:---|:---|:---|
| ✅ 実行完了 | XX | すべて実行 |
| ❌ 未実行 | 0 | 問題なし |
| ⚠️ 仕様書外実行 | 0 | 問題なし |

詳細は [test-case-execution-verification.md](test-case-execution-verification.md) を参照

## テスト結果一覧
| テストケースID | テスト名 | ステータス | 期待結果 | 実際結果 | 処理時間 | スクリーンショット |
|:---|:---|:---|:---|:---|:---|:---|
| TC001 | 正常ログイン | ✅ PASS | ダッシュボード表示 | ダッシュボード表示 | 1333ms (1.333秒) | [📷](screenshots/TC001-final.png) |
| TC002 | 無効なメール形式 | ❌ FAIL | エラーメッセージ表示 | エラーメッセージなし | 111ms (0.111秒) | [📷](screenshots/TC002-final.png) |

## 全テストケース詳細

### TC001: 正常ログイン ✅ PASS
- **テスト対象**: ログイン画面
- **テストURL**: https://example.com/login
- **実行時間**: 3.5秒

#### 操作手順
1. ログイン画面に遷移
2. メールアドレス入力: `test@example.com`
3. パスワード入力: `password123`
4. ログインボタンをクリック

#### 処理時間
- **処理対象ボタン**: ログインボタン
- **開始時刻**: 2025-01-01 10:00:03.123
- **終了時刻**: 2025-01-01 10:00:04.456
- **処理時間**: 1333ms (1.333秒)

#### 期待結果
- ダッシュボード画面に遷移（URL: `https://example.com/dashboard`）
- ページタイトル: 「ダッシュボード」
- ユーザー名表示: 「テストユーザー」

#### 実際結果
- ✅ ダッシュボード画面に遷移（URL: `https://example.com/dashboard`）
- ✅ ページタイトル: 「ダッシュボード」
- ✅ ユーザー名表示: 「テストユーザー」

#### スクリーンショット
- [操作前: ログイン画面](screenshots/TC001-step1-before.png)
- [操作後: ダッシュボード画面](screenshots/TC001-step4-after.png)

#### 検証結果
- ✅ URL遷移: 期待値 = 実際値
- ✅ ページタイトル: 期待値 = 実際値
- ✅ ユーザー名表示: 期待値 = 実際値

#### 実行ログ
```
[2025-01-01 10:00:00] テストケース開始: TC001
[2025-01-01 10:00:01] ページ遷移: https://example.com/login
[2025-01-01 10:00:02] フォーム入力: email = test@example.com
[2025-01-01 10:00:02] フォーム入力: password = ********
[2025-01-01 10:00:03.123] ボタンクリック開始: ログイン（処理時間測定開始）
[2025-01-01 10:00:04.456] 処理完了: ダッシュボード画面への遷移完了（処理時間: 1333ms）
[2025-01-01 10:00:04] スナップショット取得: ダッシュボード画面
[2025-01-01 10:00:05] 検証完了: すべてのアサーション成功
[2025-01-01 10:00:05] テストケース終了: TC001 - PASS
```

#### ブラウザコンソール
```
(コンソール出力なし)
```

---

### TC002: 無効なメール形式 ❌ FAIL
- **テスト対象**: ログイン画面
- **テストURL**: https://example.com/login
- **実行時間**: 2.1秒

#### 操作手順
1. ログイン画面に遷移
2. メールアドレス入力: `invalid-email`
3. パスワード入力: `password123`
4. ログインボタンをクリック

#### 処理時間
- **処理対象ボタン**: ログインボタン
- **開始時刻**: 2025-01-01 10:00:08.234
- **終了時刻**: 2025-01-01 10:00:08.345
- **処理時間**: 111ms (0.111秒)

#### 期待結果
- ログイン画面にとどまる
- エラーメッセージ表示: 「メールアドレスの形式が正しくありません」
- ログインボタンが非活性

#### 実際結果
- ✅ ログイン画面にとどまる
- ❌ エラーメッセージが表示されない
- ❌ ログインボタンが活性のまま

#### スクリーンショット
- [操作前: ログイン画面](screenshots/TC002-step1-before.png)
- [操作後: エラーメッセージなし](screenshots/TC002-step4-after.png)

#### 検証結果
- ✅ URL: 期待値 = 実際値（ログイン画面のまま）
- ❌ エラーメッセージ: 期待値「メールアドレスの形式が正しくありません」が表示されない
- ❌ ログインボタン状態: 期待値「非活性」≠ 実際値「活性」

#### 差分
- エラーメッセージが表示されない
- バリデーション処理が実装されていない可能性

#### 実行ログ
```
[2025-01-01 10:00:06] テストケース開始: TC002
[2025-01-01 10:00:07] ページ遷移: https://example.com/login
[2025-01-01 10:00:07] フォーム入力: email = invalid-email
[2025-01-01 10:00:08] フォーム入力: password = ********
[2025-01-01 10:00:08.234] ボタンクリック開始: ログイン（処理時間測定開始）
[2025-01-01 10:00:08.345] 処理完了: バリデーション処理完了（処理時間: 111ms）
[2025-01-01 10:00:08] スナップショット取得: ログイン画面
[2025-01-01 10:00:08] 検証失敗: エラーメッセージが見つからない
[2025-01-01 10:00:09] テストケース終了: TC002 - FAIL
```

#### ブラウザコンソール
```
console.error: Validation error: Invalid email format
```

---

## 実行ログサマリー
```
UIテスト実行開始: 2025-01-01 10:00:00
ブラウザ起動: Chromium
ウィンドウサイズ: 1920x1080

テストケース実行:
✓ TC001: 正常ログイン (3.5s) [処理時間: 1333ms]
✗ TC002: 無効なメール形式 (2.1s) [処理時間: 111ms]

実行完了: 2025-01-01 10:00:09
総実行時間: 9.0s
成功: 1 / 失敗: 1

処理時間サマリー:
- ログインボタン処理時間（TC001）: 1333ms (1.333秒)
- ログインボタン処理時間（TC002）: 111ms (0.111秒)
- 平均処理時間: 722ms (0.722秒)
```

## ブラウザコンソールログ
```
[TC002] console.error: Validation error: Invalid email format
```

## 推奨事項
- TC002: メールアドレスのバリデーション処理を実装してください
- エラーメッセージを適切に表示するUIを追加してください
```

## 画面要素の特定方法

### Playwright MCP での要素特定
1. **`browser_snapshot` を使用**:
   - ページの構造を取得し、操作可能な要素のリストを確認
   - 各要素には人間が読める説明と `ref` が含まれる
   
2. **`ref` の使用**:
   - スナップショットから取得した `ref` を使って要素を操作
   - 例：`browser_click(element="ログインボタン", ref="button-submit-123")`
   
3. **要素が見つからない場合**:
   - `browser_wait_for` で要素の表示を待機
   - ページの読み込み完了を確認
   - 別のセレクター戦略を試す

### 実装例
```markdown
## テスト実行フロー

1. ページに遷移: `browser_navigate(url="https://example.com/login")`
2. ページ構造を取得: `browser_snapshot()`
3. スナップショット結果から要素を特定:
   - メール入力欄: `ref="input-email-456"`
   - パスワード入力欄: `ref="input-password-789"`
   - ログインボタン: `ref="button-submit-123"`
4. フォームに入力: `browser_fill_form(fields=[...])`
5. ボタンをクリック: `browser_click(element="ログインボタン", ref="button-submit-123")`
   - **処理時間測定**: クリック前の時刻を記録
   - **処理完了待機**: `browser_wait_for` で成功メッセージ/画面遷移/エラーメッセージを待機
   - **処理時間計算**: 処理完了後の時刻を記録し、処理時間を計算
6. 結果を検証: `browser_snapshot()` で画面状態を確認
7. スクリーンショットを保存: `browser_take_screenshot(filename="TC001-final.png")`
```

## UIテスト仕様書への結果反映（必須）

### ステップ6: 仕様書への結果反映
7. **UIテスト仕様書の更新**  
   - テスト実行完了後、**元のUIテスト仕様書**（`docs/tests/ui/*.md`）に実行結果を反映する
   - **重要**: 仕様書の内容は保持し、結果情報のみを追加/更新する
   - **必須**: すべてのテストケースの実行結果、エビデンスパス、実行日時を反映

### 反映対象ファイル
- 実行対象となった `docs/tests/ui/*.md` ファイル
- 複数ファイルを実行した場合は、すべてのファイルに結果を反映

### 反映内容
1. **テスト実行サマリー**（ファイル末尾に追加）
2. **各テストケースの実行結果**（該当するテストケース行に追加）
3. **エビデンスリンク**
4. **実行履歴**

### 反映フォーマット

#### 1. テスト実行サマリー（ファイル末尾に追加）
```markdown
---

## テスト実行履歴

### 最新実行結果
- **実行日時**: YYYY-MM-DD HH:MM:SS
- **総テスト数**: XX
- **成功**: XX
- **失敗**: XX
- **実行時間**: XXXms
- **カバレッジ**: XX% (実行済み XX / 総数 XX)
- **エビデンス**: [📁 結果詳細](../ui_results/<テスト仕様書名>/test-results-summary.md)

#### 実行結果一覧
| テストケースID | テスト名 | 結果 | 実行日時 | エビデンス |
|:---|:---|:---|:---|:---|
| TC001 | 正常ログイン | ✅ PASS | YYYY-MM-DD HH:MM:SS | [📷](../ui_results/<テスト仕様書名>/screenshots/TC001-final.png) |
| TC002 | 無効なメール形式 | ❌ FAIL | YYYY-MM-DD HH:MM:SS | [📷](../ui_results/<テスト仕様書名>/screenshots/TC002-final.png) |

#### 失敗テストケース詳細
- **TC002: 無効なメール形式**
  - エラー内容: エラーメッセージが表示されない
  - 修正が必要: メールアドレスのバリデーション処理

### 実行履歴
| 実行日時 | 成功/失敗 | 総数 | 備考 |
|:---|:---|:---|:---|
| YYYY-MM-DD HH:MM:SS | XX/XX | XX | 初回実行 |
```

#### 2. テストケーステーブルへの結果反映
既存のテストケーステーブル（「テスト仕様書」「バリエーション」）に列を追加：

**実行前のテーブル例**:
| No | テストケースID | 操作手順 | 期待結果 |
|:---|:---|:---|:---|
| 1 | TC001 | ログイン画面でメールアドレスとパスワードを入力 | ダッシュボード画面に遷移 |

**実行後のテーブル例**:
| No | テストケースID | 操作手順 | 期待結果 | 最新実行結果 | 実行日時 | エビデンス |
|:---|:---|:---|:---|:---|:---|:---|
| 1 | TC001 | ログイン画面でメールアドレスとパスワードを入力 | ダッシュボード画面に遷移 | ✅ PASS | YYYY-MM-DD HH:MM:SS | [📷](../ui_results/<テスト仕様書名>/screenshots/TC001-final.png) |
| 2 | TC002 | 無効なメールアドレスを入力してログインボタンクリック | エラーメッセージ表示 | ❌ FAIL | YYYY-MM-DD HH:MM:SS | [📷](../ui_results/<テスト仕様書名>/screenshots/TC002-final.png) |

### 反映ルール
1. **既存内容の保持**
   - 仕様書の元の内容（概要、操作手順、期待結果等）は変更しない
   - テストケースの定義は保持する

2. **結果情報の追加**
   - 既存テーブルに列を追加して実行結果を反映
   - ファイル末尾にテスト実行サマリーを追加

3. **更新方法**
   - 初回実行時: 新しい列とサマリーセクションを作成
   - 再実行時: 既存の結果情報を最新の結果で上書き
   - 実行履歴は蓄積（削除しない）

4. **エラー処理**
   - テーブル構造が異なる場合: 警告を出力し、可能な範囲で反映
   - ファイル書き込みに失敗した場合: エラーを報告し、実行結果ファイルのみ保存

### 反映タイミング
- **必須**: テスト実行完了直後に反映
- **順序**: エビデンス保存 → 仕様書更新 → 完了報告

### 実装注意事項
1. **マークダウン構造の保持**
   - 既存の見出し構造を壊さない
   - テーブルフォーマットを正しく維持

2. **文字エンコーディング**
   - UTF-8（BOMなし）で保存
   - 改行コードはLF（Unix形式）を使用

3. **リンクパスの相対参照**
   - エビデンスファイルへのパスは相対パスを使用
   - `../ui_results/<テスト仕様書名>/` 形式

4. **バックアップ**
   - 仕様書更新前に、元ファイルのバックアップは不要（Gitで管理されているため）
   - 更新に失敗した場合のみ、エラーを報告

### 反映例
**更新前のファイル**: docs/tests/ui/login-screen-test-spec.md
**更新後のファイル**: 同じファイルに実行結果が追加される

これにより、テスト仕様書が「活きたドキュメント」として、常に最新のテスト結果を含む状態になります。

## 注意事項
- **⚠️ 最重要**: すべてのテストケースの実行が完了するまで、Cursorの実行を終了させてはならない。各ツール呼び出しの完了を待機し、すべてのテストケースが完了するまで継続すること
- **⚠️ 最重要**: テスト実行中は、実行完了確認を行い、すべてのテストケースが完了するまで次のステップに進まないこと
- Playwright MCP ツールを直接呼び出すため、テストスクリプトファイルは作成しない
- 各テストケースの実行結果は、MCP ツールの戻り値から取得する
- スクリーンショットは `browser_take_screenshot` で保存し、ファイル名を記録する
- ブラウザコンソールは `browser_console_messages` で取得する
- エラー発生時は、できるだけ詳細な情報を記録する（スクリーンショット、コンソールログ、ページHTML等）
- テスト実行前に、必ず `browser_snapshot` でページ構造を確認し、正しい `ref` を使用する
- **必須**: 各ツール呼び出しの完了を待機し、結果を確認してから次の操作に進むこと（非同期処理の完了を確実に待機）
- **処理時間測定の実装（ストップウォッチ方式）**:
  - **基本方針**: `browser_evaluate` と `browser_wait_for` を組み合わせて、`waitForFunction()` 相当の処理を実装し、ストップウォッチ方式で時間を計測する
  - **開始時刻の記録**: ボタンクリック操作（`browser_click`）実行前に、`browser_evaluate` で `performance.now()` を使用して開始時刻を記録（高精度タイムスタンプ、マイクロ秒精度）
    - `performance.now()` は `Date.now()` よりも高精度で、システムクロックの影響を受けない
    - ブラウザ内の `window.testStopwatch` オブジェクトに開始時刻を保存
  - **処理中の監視**: クリック後、`browser_wait_for` で処理完了を待機しながら、`browser_evaluate` で定期的に経過時間を確認（オプション）
    - 長時間処理の場合は、処理中に経過時間をログ出力することを推奨
  - **処理完了の判定**: 以下のいずれかで処理完了と判定
    - 成功メッセージの表示（`browser_wait_for` で成功メッセージのテキストを待機）
    - 画面遷移の完了（URL変更の確認）
    - エラーメッセージの表示（異常系テストの場合、`browser_wait_for` でエラーメッセージのテキストを待機）
    - ローディング表示の消滅（ローディングインジケーターの非表示）
  - **終了時刻の記録**: 処理完了判定後、`browser_evaluate` で `performance.now()` を使用して終了時刻を取得
  - **処理時間の計算**: 終了時刻 - 開始時刻で処理時間（ミリ秒）を計算
  - **記録**: 処理時間は各テストケースの実行結果に含め、サマリーファイルに記載する
    - 処理対象ボタン名（例: 「ログインボタン」「アップロードボタン」等）
    - 開始時刻（YYYY-MM-DD HH:MM:SS.mmm）
    - 終了時刻（YYYY-MM-DD HH:MM:SS.mmm）
    - 処理時間（ミリ秒、秒単位も併記）
  - **複数ボタンの場合**: 各ボタンごとに個別のストップウォッチを起動し、処理時間を記録する
  - **実装例**:
    ```javascript
    // 1. ストップウォッチ開始
    await browser_evaluate(() => {
      window.testStopwatch = {
        start: performance.now(),
        startTimestamp: new Date().toISOString(),
        logs: []
      };
    });
    
    // 2. ボタンクリック
    await browser_click(element="一括処理ボタン", ref="e414");
    
    // 3. 処理完了を待機（成功メッセージまたはエラーメッセージ）
    await browser_wait_for(text="処理が完了しました");
    // または
    await browser_wait_for(text="エラー");
    
    // 4. 処理時間を取得
    const timing = await browser_evaluate(() => {
      const end = performance.now();
      return {
        start: window.testStopwatch.start,
        end: end,
        elapsed: end - window.testStopwatch.start,
        startTimestamp: window.testStopwatch.startTimestamp,
        endTimestamp: new Date().toISOString()
      };
    });
    
    // 5. 結果を記録
    console.log(`処理時間: ${timing.elapsed}ms (${(timing.elapsed / 1000).toFixed(2)}秒)`);
    ```
- **テストデータファイルの扱い（ファイルアップロードテスト）**:
  - プロンプトでテストデータファイルが指定されている場合、または仕様書にファイルアップロードが必要と記載されている場合は、必ずテストデータファイルを準備する
  - テストデータファイルは標準配置場所（`.cursor/rules/R06_IT_Test/R0602_Ui_Test_Automation/test-data/`）から読み込む
  - テストデータファイルの存在確認とパス解決は `browser_evaluate` でNode.jsの `fs` と `path` モジュールを使用する
  - テストデータファイルが存在しない場合は、エラーメッセージを出力し、テストをスキップまたは失敗とする
  - ファイルパスは必ず絶対パスに変換する（`browser_file_upload` は絶対パスを要求するため）
  - テストデータファイルの内容（機密情報が含まれる可能性があるため）は実行ログに記録しない。ファイルパスとファイル名のみを記録する
  - ファイルアップロード後は、必ずアップロード処理の完了を待機し、成功メッセージまたはエラーメッセージを確認する
  - アップロード成功時は、データの反映確認（一覧画面への追加等）も行う
- **新規追加**: テスト実行完了後、必ず元のUIテスト仕様書に結果を反映すること
- **新規追加**: 仕様書更新時は既存の内容を保持し、結果情報のみを追加/更新すること
- **新規追加**: セッションクリア検証（localStorage/sessionStorage）のテストケースでは、`browser_evaluate`ツールを使用してlocalStorage/sessionStorage/DOM要素の状態をプログラム的に検証し、スクリーンショットだけでは確認できない内部状態の変化を記録する
- **新規追加**: セッションクリア検証の検証結果（localStorage/sessionStorage/DOM要素の値）は詳細レポートファイル（`<test-case-id>-detail-report.md`）に保存し、開発者ツールのGUIスクリーンショットは取得できない制約を明記する

### データ前提と自動準備（新規追加）
- **ページネーション前提の自動化**:
  - ページネーション系を実行する際、テスト対象画面の1ページあたりの表示件数（ページサイズ）をテスト仕様書やUIから読み取る。
  - 既存件数がページサイズちょうどの場合、2ページ目が表示されない実装が想定されるため、テスト開始前に「ページサイズ + 1件以上」になるように調整する。
  - 既存件数が「ページサイズ + 1件」未満の場合のみ、テスト対象となるデータストア（例: DynamoDB、MySQL等）にテスト用ダミーデータを追加して件数を「ページサイズ + 1件」以上にする。
  - データストアのテーブル名や項目名は、テスト仕様書やテーブル定義.mdを参照して決定する。
  - 追加データはテスト終了後に必ず削除して元の状態へ復元する（追加・削除はエビデンスに件数スクリーンショットを残す）。

- **データ追加/削除の実行手段**:
  - Playwright MCP 実行の妨げにならない範囲で、適切な手段（AWS SDK、AWS CLI、データベースクライアント等）を使用してデータの追加/削除を行ってよい。
  - 追加する項目は、テスト仕様書やテーブル定義.mdに基づいて最小限の必須項目のみとする。
  - 追加件数は「（ページサイズ + 1件）に満たない差分分」のみとし、テスト終了後は追加したキー（主キーまたは一意キー）に限定して削除する。

- **権限制御の自動判定と期待値**:
  - テスト仕様書に権限による表示制御が記載されている場合、ログイン後の権限表示や画面情報を参照して適切な期待値を設定する。
  - テスト仕様書で「管理者のみ」「編集者以上」などの条件が指定されている場合、該当する権限でログインした状態での画面要素の表示/非表示を検証する。
  - 権限不足で非表示になるべき要素が表示されている場合はテスト失敗とし、スクリーンショットと `browser_snapshot` の抜粋を保存する。

- **証跡取得の標準化**:
  - ページネーション実行時は、以下の画面を最低1枚ずつ保存する。
    - 1ページ目（件数とページ番号 UI を含む）
    - 2ページ目（最終ページを含む）
    - ページサイズ変更時（ドロップダウンで選択可能な各ページサイズでの選択状態と行数）

- **失敗時の自動リトライと代替検証**:
  - ページネーション UI が見つからない場合は、`browser_evaluate` で `table tbody tr` の行数とページサイズ表示テキストを採取し、期待に合致するかの代替検証を行う（その結果を詳細レポートに残す）。


